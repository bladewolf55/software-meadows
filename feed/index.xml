<?xml version="1.0" encoding="utf-8"?><rss xmlns:a10="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Software Meadows</title><description>A pleasant walk through computing</description><managingEditor>noreply@example.com</managingEditor><a10:link href="https://www.softwaremeadows.comfeed/" /><item xml:base="https://www.softwaremeadows.com/posts/my_mixed_relationship_with_tdd"><title>My Mixed Relationship with TDD</title><description>&lt;p&gt;&lt;img src="images/tdd-created-by-nasa.jpg" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;OK, not completely &amp;quot;created by,&amp;quot; but &lt;a href="https://arialdomartini.wordpress.com/2012/07/20/you-wont-believe-how-old-tdd-is/"&gt;You won't believe how old TDD is&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id="intro"&gt;Intro&lt;/h2&gt;
&lt;p&gt;I have a mixed relationship with Test-Driven Development (TDD). It's a valuable method that I've enjoyed--when I've used it. What matters more to me than test-first is creating automated tests early rather than late.&lt;/p&gt;
&lt;p&gt;Despite my on-again, off-again history with TDD, I've written about it in tutorial form. This series also includes examples of mocking and dependency injection. What to mock is, I think, especially difficult to get right.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.softwaremeadows.com/posts/catching-up-on-coding-tdd-part-1/"&gt;Catching Up On Coding - TDD Part 1 | Software Meadows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.softwaremeadows.com/posts/catching-up-on-coding-tdd-part-2/"&gt;Catching Up On Coding - TDD Part 2 | Software Meadows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.softwaremeadows.com/posts/catching-up-on-coding-tdd-part-3/"&gt;Catching Up On Coding - TDD Part 3 | Software Meadows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="history"&gt;History&lt;/h2&gt;
&lt;p&gt;In 2001, at the beginning of the third millenium, I first learned about some eXtreme Programming (XP) practices, among them TDD. I wanted to try this out, but ran into a snag: Visual Basic 6 didn't have a good unit testing framework. &lt;a id="fnref:1" href="#fn:1" class="footnote-ref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; So, I wrote my own. I also wrote it to test &lt;em&gt;private&lt;/em&gt; methods, because that's where the action was, and I hadn't yet wrapped my head around why testing public methods was key to keeping tests separate from code.&lt;/p&gt;
&lt;p&gt;Even then, I got the TDDers thrill from seeing all green after running tests. However, my organization wasn't invested in TDD, so I set it aside. This was the story for the next couple of decades. The places I worked didn't care about more agile methods, and my efforts to introduce and use TDD didn't go far. Over time, I realized something else. My background in creative writing and music composition led me intuitively write code in a particular way:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Draft the code, getting some things working quickly.&lt;/li&gt;
&lt;li&gt;Significantly rewrite as the better structure reveals itself.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TDD didn't fit into this way of coding new projects, because my code would often change a &lt;em&gt;lot&lt;/em&gt; as I settled on the most effective patterns. In business parlance, this is a &amp;quot;fail early, fail often&amp;quot; approach. Writing tests first at this stage worked against me because the methods I was testing were in flux. Heck, the whole approach was in flux. I could delete them at any moment. It took me a long time to reconcile how to integrate unit testing and TDD into my personal, fluid--and effective--style of coding.&lt;/p&gt;
&lt;p&gt;One developer I talked with said his team didn't practice &amp;quot;test first,&amp;quot; but instead &amp;quot;test eventually.&amp;quot; I stored this tidbit away, though something nagged at me. How often was &amp;quot;test eventually&amp;quot; turning into &amp;quot;test never?&amp;quot;&lt;/p&gt;
&lt;h2 id="database-testing"&gt;Database Testing&lt;/h2&gt;
&lt;p&gt;Another obstacle on my road to successful unit testing was how to deal with databases. This wasn't just my obstacle, of course. It hung up loads of developers. The Repository Pattern was known, but not well-understood or encouraged in the Microsoft world. Abstracting the database seemed--and often was--tedious, time-consuming, and prohibitively maintenance-heavy. What kind of software was I writing all the time? Yep, database-centric.&lt;/p&gt;
&lt;p&gt;Things didn't because easier with the adoption of Entity Framework (or Linq2Sql). When it came to testing, Microsoft's own documentation often recommended Repository Pattern, and sometimes Unit of Work.&lt;a id="fnref:2" href="#fn:2" class="footnote-ref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; This was frankly a mess. Why? Because EF was itself built using Repository (DbSet) and Unit of Work (DbContext) patterns.&lt;a id="fnref:3" href="#fn:3" class="footnote-ref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; So, developers were writing &lt;em&gt;an abstraction on top of an abstraction&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Again, I was hampered by a couple of things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;When a regular employee, I wasn't working in an agile environment.&lt;/li&gt;
&lt;li&gt;When a contractor, I was often constrained by client expectations.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="today"&gt;Today&lt;/h2&gt;
&lt;p&gt;Over the years, I've returned to TDD several times and have come to some tentative conclusions.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For me, on a greenfield project, test-first shouldn't be introduced immediately, but only after going through my drafting/iterating process to help clarify how &amp;quot;the code wants to be written&amp;quot; (I agree, a squishy, woo-woo statement.)&lt;/li&gt;
&lt;li&gt;After that, TDD is a big help, primarily because it forces tests to be written in parallel to coding &lt;em&gt;and&lt;/em&gt; forces useful abstractions and separation of concerns.&lt;/li&gt;
&lt;li&gt;Sometimes, though, TDD needs to be set aside while a coding solution is explored via a deep dive. Avoid &lt;em&gt;premature testing&lt;/em&gt;. In these cases, the developer's mind needs to &lt;em&gt;flow&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Testing reveals architecture problems&lt;/em&gt;. This is another top value. In order for code to be testable, it needs to be well-architected using dependency injection and coding to interfaces.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I'm insisting on unit tests in my code, and forcing myself to use TDD in my workflow. This will require reading about modern TDD, and being confronted with terrific articles such as &lt;a href="http://blog.cleancoder.com/uncle-bob/2017/03/03/TDD-Harms-Architecture.html"&gt;TDD Harms Architecture&lt;/a&gt; by &amp;quot;Uncle Bob&amp;quot; Martin.&lt;/p&gt;
&lt;h2 id="other-thoughts"&gt;Other Thoughts&lt;/h2&gt;
&lt;h3 id="not-design"&gt;Not &amp;quot;Design&amp;quot;&lt;/h3&gt;
&lt;p&gt;TDD is &lt;em&gt;not&lt;/em&gt; design. Some people want the acronym to be Test Driven Design. But TDD isn't designing anything, except in the very loosest sense that programmers are always designing a method before coding it. We at least &lt;em&gt;imagine&lt;/em&gt; how it's going to work, and that's--again, loosely--design. Robert Martin says it emphatically:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The idea that the high level design and architecture of a system emerge from TDD is, frankly, absurd. Before you begin to code any software project, you need to have some architectural vision in place. TDD will not, and can not, provide this vision. That is not TDD’s role.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And goes on to say&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, this does not mean that designs do not emerge from TDD – they do; just not at the highest levels. The designs that emerge from TDD are one or two steps above the code;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="favorite-framework"&gt;Favorite Framework&lt;/h3&gt;
&lt;p&gt;That's easy. &lt;a href="https://xunit.net/"&gt;xUnit.net&lt;/a&gt;. I've loved it since its early days. Now, I've often used MSTest because it's A) built-in, and/or B) it's what the development shop was already using. But I prefer xUnit.net and its features such as Theories.&lt;/p&gt;
&lt;p&gt;Using one of the &amp;quot;Should&amp;quot;&lt;a id="fnref:4" href="#fn:4" class="footnote-ref"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; libraries makes unit testing even more readable.&lt;/p&gt;
&lt;h2 id="wrap-up"&gt;Wrap-Up&lt;/h2&gt;
&lt;p&gt;Testing is hard. Unit testing is hard. But early, automated testing builds confidence in the system, and TDD provides a valuable feedback loop that stacks nicely on other methods such as continuous integration.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;This isn't quite true. There was a framework, but my misunderstanding of why only public methods should be tested interfered with me using it.&lt;a href="#fnref:1" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Such as this untestable craziness: &lt;a href="https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application"&gt;Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application (9 of 10) | Microsoft Docs&lt;/a&gt;&lt;a href="#fnref:2" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;But not until EF 4.1, and mocking wasn't easy-ish until 6.0.&lt;a href="#fnref:3" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;&lt;a href="https://github.com/shouldly/shouldly"&gt;shouldly&lt;/a&gt; and &lt;a href="https://fluentassertions.com/"&gt;Fluent Assertions&lt;/a&gt;&lt;a href="#fnref:4" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description><pubDate>Tue, 30 Apr 2019 09:24:00 -0600</pubDate></item></channel></rss>