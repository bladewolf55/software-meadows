<?xml version="1.0" encoding ="UTF-8"?>
<rss xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" version="2.0">
  <channel>
    <title>Software Meadows</title>
    <description>A pleasant walk through computing</description>
    <link>https://www.softwaremeadows.com/feed</link>
    <link href="https://www.softwaremeadows.com/feed" rel="self" type="application/rss+xml" xmlns="http://www.w3.org/2005/Atom" />
    <item>
      <title>Remote Work Tiny Tips - Keeping Your Routine</title>
      <description>&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/remote_work_tiny_tips_-_forming_new_habits/images/alexander_graham_bell_sm.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;It's relatively easy to get the technology running to work from home. The hard part is the &lt;em&gt;doing&lt;/em&gt;. Don't beat yourself up! Try this tiny tip on...&lt;/p&gt;
&lt;h1 id="keeping-your-routine"&gt;Keeping Your Routine&lt;/h1&gt;
&lt;p&gt;Here are just a few steps to help you &amp;quot;remote&amp;quot; as well as you &amp;quot;on-sited.&amp;quot;&lt;a id="fnref:1" href="#fn:1" class="footnote-ref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="love-your-old-routine"&gt;1. Love Your Old Routine&lt;/h2&gt;
&lt;p&gt;Write out your previous on-site routine, starting from when you woke up to what you did first thing after getting to work. For example:&lt;/p&gt;
&lt;div style="font-family: Comic Sans MS, Comic Sans, Apple Cancery, cursive;"&gt;
&lt;ol&gt;
&lt;li&gt;Turn off alarm.&lt;/li&gt;
&lt;li&gt;Throw back covers, feet on floor.&lt;/li&gt;
&lt;li&gt;Bathroom, splash face with water.&lt;/li&gt;
&lt;li&gt;Shower, brush hair, makeup (or shave).&lt;/li&gt;
&lt;li&gt;Dress in front of mirror.&lt;/li&gt;
&lt;li&gt;Coffee. Breakfast.&lt;/li&gt;
&lt;li&gt;Drive to work. Listen to news.&lt;/li&gt;
&lt;li&gt;Go to break room. More coffee.&lt;/li&gt;
&lt;li&gt;Start computer. Log on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;etc.&lt;/p&gt;
&lt;/div&gt;
    
Savor that list. It's your warm friend. Even if it was a hassle sometimes...
&lt;blockquote&gt;
&lt;p&gt;That's the routine you're used to, that tells you &amp;quot;It's time to work!&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="discover-your-new-routine-is-mostly-the-same"&gt;2. Discover Your New Routine (Is Mostly the Same)!&lt;/h2&gt;
&lt;p&gt;Make a copy of that list and mark out &lt;em&gt;only&lt;/em&gt; the things that you &lt;em&gt;can't&lt;/em&gt; do at home.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You'll probably find that most of your routine can stay the same.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="do-your-new-routine-with-a-twist-and-shout"&gt;3. Do Your New Routine With a Twist--and Shout&lt;/h2&gt;
&lt;p&gt;Emotions drive behavior. We'll rationalize the behavior afterward, but loads of research keeps showing us the truth:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Emotions Drive Behavior&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, for the next few days, as goofy as it sounds, do one, simple thing.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Celebrate after &lt;em&gt;each step&lt;/em&gt; in your new routine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Not half-heartedly. Give it! A big smile, a fist pump, say &amp;quot;That's the way!&amp;quot; Doing this will fire off dopamine in your brain, which will make you feel good, which will make you want to keep doing the routine.&lt;a id="fnref:2" href="#fn:2" class="footnote-ref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Micro-celebrations are the easy &amp;quot;Likes&amp;quot; you give yourself.&lt;/p&gt;
&lt;h2 id="and-finally"&gt;And Finally&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Effort leads to improvement&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Please never use the word &amp;quot;on-sited.&amp;quot;&lt;a href="#fnref:1" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Science.&lt;a href="#fnref:2" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
      <pubDate>Wed, 18 Mar 2020 17:57:00 -0600</pubDate>
      <link>https://www.softwaremeadows.com/posts/remote_work_tiny_tips_-_forming_new_habits</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/remote_work_tiny_tips_-_forming_new_habits</guid>
    </item>
    <item>
      <title>Continuous Integration Flow - An Accurate and Unlovely Graphic</title>
      <description>&lt;p&gt;I needed to explain this to a colleague recently, took a picture of my whiteboard drawing, then digitized it using Inkscape. I've also linked to a PDF version. It says &amp;quot;Azure DevOps,&amp;quot;, but it's a pretty generic depiction.&lt;/p&gt;
&lt;p&gt;It ain't pretty, but it's correct.&lt;/p&gt;
&lt;p&gt;Hope it helps someone!&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.softwaremeadows.com/posts/continuous_integration_flow_-_an_accurate_and_unlovely_graphic/images/Continuous%20Integration%20Flow.pdf"&gt;Continuous Integration Flow.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/continuous_integration_flow_-_an_accurate_and_unlovely_graphic/images/Continuous%20Integration%20Flow.svg" alt="" /&gt;&lt;/p&gt;
</description>
      <pubDate>Wed, 11 Mar 2020 21:17:00 -0600</pubDate>
      <link>https://www.softwaremeadows.com/posts/continuous_integration_flow_-_an_accurate_and_unlovely_graphic</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/continuous_integration_flow_-_an_accurate_and_unlovely_graphic</guid>
    </item>
    <item>
      <title>Why the Repository Pattern Fails for Legacy Databases Like Yours and What to Do About It</title>
      <description>&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/File:Repo-Man-Poster.jpg#/media/File:Repo-Man-Poster.jpg"&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/en/4/46/Repo-Man-Poster.jpg" alt="Repo-Man-Poster.jpg"&gt;&lt;/a&gt;&lt;br&gt;By Source, &lt;a href="//en.wikipedia.org/wiki/File:Repo-Man-Poster.jpg" title="Fair use of copyrighted material in the context of Repo Man (film)"&gt;Fair use&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/w/index.php?curid=10827447"&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction:-a-classic-example-(spot-the-flaw?)"&gt;Introduction: A Classic Example (spot the flaw?)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#implicit-architecture-rules"&gt;Implicit Architecture Rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-unnecessary-abstraction"&gt;The Unnecessary Abstraction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cutting-out-the-middleman"&gt;Cutting Out the Middleman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#your-data-sources-will-change..."&gt;Your Data Sources Will Change...&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="introduction-a-classic-example-spot-the-flaw"&gt;Introduction: A Classic Example (spot the flaw?)&lt;/h2&gt;
&lt;p&gt;One of the hallmarks of creating a loosely coupled architecture is using the repository pattern to return data. Each model's repository is implemented from an interface, and that interface is injected into, typically, a service.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Domain.DomainModels
{
    public class Customer
    {
        public int CustomerId {get; set;}
        public string Name {get; set;}
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Domain.DataInterfaces
{
    public interface IRepository&amp;lt;T&amp;gt; where T: class
    {
        T Single(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt; where);
        IEnumerable&amp;lt;T&amp;gt; Many(Expression&amp;lt;Func&amp;lt;T, bool&amp;gt; where);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The concrete implementation, using Entity Framework 6.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Data
    public class CustomerRepository: IRepository&amp;lt;Customer&amp;gt;
    {
        CompanyDbContext _context = new CompanyDbContext();
        Customer Single(Expression&amp;lt;Func&amp;lt;Customer, bool&amp;gt; where)
        {
            return _context.Customers.SingleOrDefault(where);   
        }
        IEnumerable&amp;lt;Customer&amp;gt; Many(Expression&amp;lt;Func&amp;lt;Customer, bool&amp;gt; where)
        {
            return _context.Customers.Where(where);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The concrete customer service with the repository interface injected.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Services
{
    public class CustomerService: ICustomerService
    {
        IRepository&amp;lt;Customer&amp;gt; _customerRepository;
        
        public CustomerService(IRepository&amp;lt;Customer&amp;gt; customerRepository)
        {
            _customerRepository = customerRepository
        }
        
        public Customer GetCustomer(int id)
        {
            return _customerRepository.Single(a =&amp;gt; a.CustomerId == id);
        }
        
        public List&amp;lt;Customers&amp;gt; GetCustomers(Expression&amp;lt;Func&amp;lt;Customer, bool&amp;gt;&amp;gt; where)
        {
            return _customerRepository.Many(where);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A unit test. (Note this is a lousy unit test because it's &amp;quot;testing&amp;quot; a data passthrough, but it illustrates the point.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using XUnit;
using NSubstitute;
using FluentAssertions;

namespace Company.Tests
{
    public class CustomerService_Should
    {
        [Fact]
        public void Return_one_customer()
        {
            int id = 1;
            Customer expected = new Customer() {CustomerId = 1;}
            var customerRepository = Substitute.For&amp;lt;IRepository&amp;lt;Customer&amp;gt;&amp;gt;();
            var customerService = new CustomerService(customerRepository);
            customerRepository.Single((a =&amp;gt; a.CustomerId == id).Returns(expected);
            var result = customerService.GetCustomer(id);
            result.Should().BeEquivalentTo(expected);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The namespaces indicate where in the&lt;a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/"&gt; Onion Architecture&lt;/a&gt; the classes belong.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Core: &lt;code&gt;Customer&lt;/code&gt; represents a company customer. It has no behavior.&lt;/li&gt;
&lt;li&gt;Core: IRepository is our generic standard for getting data. By injecting this standard into services, we can swap out the database by simply implementing it in a new concrete repository.&lt;/li&gt;
&lt;li&gt;Core: ICustomerService is our contract for what a CustomerService should implement&lt;/li&gt;
&lt;li&gt;Data: CustomerRepository is the concrete instance that will return models from the database.&lt;/li&gt;
&lt;li&gt;Service: CustomerService is the concrete instance that returns models to the client.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hint&lt;/strong&gt; The flaw with the repository pattern is #2 and #4.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://i0.wp.com/jeffreypalermo.com/wp-content/uploads/2018/06/image257b0257d255b59255d.png?resize=366%2c259&amp;amp;ssl=1" alt="" /&gt;
Image Copyright Jeffrey Palermo&lt;/p&gt;
&lt;h2 id="implicit-architecture-rules"&gt;Implicit Architecture Rules&lt;/h2&gt;
&lt;p&gt;Implicit in the Onion architecture are these rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Domain Models represent the way the organization really works.&lt;/li&gt;
&lt;li&gt;Domain Services return Domain Models. (e.g. CustomerService returns Customer)&lt;/li&gt;
&lt;li&gt;Data Services return Data Models (e.g. CustomerRepository returns...Customer, in this case)&lt;/li&gt;
&lt;li&gt;APIs return with View Models (MVC Controllers, WebApi return something like CustomerMaintModel)&lt;/li&gt;
&lt;li&gt;UIs work with View Models&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a loosely coupled architecture. By using interfaces, it's also highly testable.&lt;/p&gt;
&lt;p&gt;So, what's wrong with it?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The repository expects to return a domain model from the database. And that's not how most databases, especially legacy databases, are designed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's make sure this is really clear, because it's the flaw in every example I've seen of this architecture. Here's how the domain and database stay loosely coupled.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The domain models represent how the organization sees information.&lt;/li&gt;
&lt;li&gt;The database models represent how the data is stored.&lt;/li&gt;
&lt;li&gt;The domain should have no knowledge of the database.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;The mistake I've seen is that organizations' repositories return their &lt;em&gt;data models&lt;/em&gt;, not domain models. They then rely on the service to map to the domain models. This means the repositories are tightly coupled to the data model.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this light, look at the classic example again. The repository returns a Customer object. Customer is a &lt;em&gt;domain&lt;/em&gt; model. This means that, if the database tables aren't one-to-one matches to the domain models, we have two choices in mapping the table model to the domain model.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use IRepository&lt;CustFile&gt; and have the CustomerService do the mapping. For instance, the &lt;code&gt;List&amp;lt;Customer&amp;gt; GetCustomers()&lt;/code&gt; method would get the data from the CustFileRepository and populate a Customer list.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is how I've seen most organizations try to do it. But we've tightly coupled our data model to our domain's IRepository. The data model is now part of the domain model. If we wanted to swap out the database, &lt;em&gt;it would have to have a CustFile table&lt;/em&gt;. If it doesn't, we're rewriting the repositories and injecting new interfaces into the services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use IRepository&lt;Customer&gt; and have the CustomerRepository do the mapping. For instance, the &lt;code&gt;IEnumerable&amp;lt;Customer&amp;gt; Many()&lt;/code&gt; method would get the data using a data model such as CustFile and populate a Customer list. There's no guarantee CustFile has the same properties as Customer.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This would be &amp;quot;more right&amp;quot; since there'd be loose coupling to the data. We could supposedly swap out the database. But as you'll see it won't work the way you think, and becomes an unnecessary layer of abstraction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's try doing the second way. But let's use a more real-world scenario.&lt;/p&gt;
&lt;p&gt;The customer data is stored in two Microsoft SQL Server tables that were created over the course of ten years. The extended table was used to handle new columns for the original table. Note the different primary key names and storing name information in a weird way. Also, there's no foreign key for the one-to-zero-one relationship.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-txt"&gt;CustFile
=========
CustId   int PK
FullName varchar(100)

CustFileExtended
===============
CustomerNumber int PK
Zip5           int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need data models specific to these tables.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Data.DataModels
{
    public class CustFile
    {
        public int CustId { get; set; }
        public string FullName { get; set; }
    }
    
    public class CustFileExtended
    {
        public int CustNumber { get; set; }
        public int Zip5 { get; set; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To keep the example clear, we'll use an explicit ICustomerRepository. Remember, in order to be loosely coupled, this repository returns a Customer domain model.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If it returned CustFile and CustFileExtended models, then those data models would have to be part of the Domain. And &lt;em&gt;that&lt;/em&gt; would tightly couple the abstract domain model to the concrete data model.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Domain.DataInterfaces
{
    public interface ICustomerRepository
    {
        // Create
        Customer Create(Customer entity);

        // Retrieve
        Customer RetrieveSingle(int id);
        IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany();
        IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany(Expression&amp;lt;Func&amp;lt;Customer, bool&amp;gt;&amp;gt; where);

        // Update
        Customer Update(Customer entity);

        // Delete
        void Delete(int id);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Note the use of Expression. That's coupling to Queryables, which are provider-dependent.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now we'll try to implement the repository using Entity Framework. To make the problem clear, we'll only look at the RetrieveMany methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Data
{
    public class CustomerRepository : ICustomerRepository
    {
        private CompanyDbContext _context;
        public CustomerRepository(CompanyDbContext context)
        {
            _context = context;
        }
        
        public IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany()
        {
            // Now what?
        }
        
        public IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany(Expression&amp;lt;Func&amp;lt;Customer, bool&amp;gt;&amp;gt; where)
        {
            // Now what?
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll assume we can mock the context somehow. But this is where things go awry.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Many organizations end up adding IRepository and IUnitOfWork to DbSet and DbContext. Patterns on top of patterns. Abstractions on top of abstractions!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How do we return a collection of Customers? Remember, we're getting the data from two different tables.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt; The calls to the database have no knowledge of what a Customer is.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany()
{
    List&amp;lt;Customer&amp;gt; customers = new List&amp;lt;Customer&amp;gt;();
    
    // there's no filtering, so get all records. That's right. ALL OF THEM.
    var custFiles = _context.CustFiles.ToList();
    int[] ids = custFiles.Select(a =&amp;gt; a.CustId).ToArray();
    var custFileExtendeds = _context.CustFileExtendeds.Where(a =&amp;gt; ids.Contains(a.CustNumber)).ToList();
    
    customers = custFiles.Select(a =&amp;gt; new Customer()
    {
       CustomerId = a.CustId,
       Name = a.FullName,
       ZipCode = custFileExtendeds.SingleOrDefault(b =&amp;gt; b.CustNumber == a.CustId)?.Zip5
    });
    
    return customers;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're using a generic repository pattern, which is typically going to include a method such as above because sometimes we &lt;em&gt;do&lt;/em&gt; want all the records. But not if there are a hundred million. OK, let's try filtering.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany(Expression&amp;lt;Func&amp;lt;Customer, bool&amp;gt;&amp;gt; where)
{
    List&amp;lt;Customer&amp;gt; customers = new List&amp;lt;Customer&amp;gt;();
    
    // And...now what?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have a filter expression that can be examined for its properties and conditions. So at first it &lt;em&gt;seems&lt;/em&gt; like all we have to do is&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Extract the Customer properties&lt;/li&gt;
&lt;li&gt;Map them to the CustFile and CustFileExtended properties&lt;/li&gt;
&lt;li&gt;Pull out the boolean conditions&lt;/li&gt;
&lt;li&gt;Create Expressions from the properties and conditions and apply the filters to the appropriate CustFile or CustFileExtended DbSets.&lt;/li&gt;
&lt;li&gt;Build and return the Customer list.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That's...actually, a lot of work. And wait...that's not complete, is it? There could be a few more steps after 4.&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;Programmatically handle a CustFile property that's filtering based on a CustFileExtended property. E.g. &lt;code&gt;Customer.Discount == Customer.MaxDiscount&lt;/code&gt;. Except in the database it's CustFile.Discount and CustFileExtended.MaxDiscount. How's that going to work?&lt;/li&gt;
&lt;li&gt;Programmatically handle nested conditions that go across table properties. Good luck to you.&lt;/li&gt;
&lt;li&gt;Hope to heck a Customer property being filtered on isn't made up of two properties from two different tables.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;and so on until...&lt;/p&gt;
&lt;ol start="99"&gt;
&lt;li&gt;Build and return the Customer list and pray it's right.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OK, so maybe we need custom repository interfaces for each domain model. Then we can make the client supply known filters like customer ids, get our initial datasets down to a managable size, then filter on the domain model.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;//No need for an Expression since List&amp;lt;Customer&amp;gt; is generic.
public IEnumerable&amp;lt;Customer&amp;gt; RetrieveMany(int zipCode, Func&amp;lt;Customer, bool&amp;gt; where)
{
    List&amp;lt;Customer&amp;gt; customers = new List&amp;lt;Customer&amp;gt;();
    var custFileExtendeds = _context.CustFileExtendeds.Where(a =&amp;gt; a.Zip5 == zipCode).ToList();
    //Build the customer list and add the filter at the end.
    return custFileExtendeds.Select(a =&amp;gt; new Customer()
    {
       CustomerId = a.CustNumber,
       ZipCode = a.Zip5,
       Name = _context.CustFiles.Single(a =&amp;gt; a.CustId == a.CustNumber).FullName
    }).Where(where);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the Service method would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public List&amp;lt;Customer&amp;gt; GetCustomers(int zipCode, Func&amp;lt;Customer, bool&amp;gt; where)
{
    return _customerRepository.RetrieveMany(zipCode, where);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seeing that service method, you're hopefully asking some important questions. Like...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What if my domain model was being populated by data from multiple databases and maybe a web service?&lt;/p&gt;
&lt;p&gt;What's the repository pattern gaining me?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="the-unnecessary-abstraction"&gt;The Unnecessary Abstraction&lt;/h2&gt;
&lt;p&gt;We've discovered a few things about having separate domain and data models.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;No matter what, we need to map data models to domain models.&lt;/li&gt;
&lt;li&gt;We can't have fully flexible filtering.&lt;/li&gt;
&lt;li&gt;The mapping problems using IRepository&lt;Customer&gt; methods are the same as with CustomerService methods. Specifically, the methods need to restrict the data that will come from the database in order for performance to be good.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There's one other requirement: whatever data sources are injected into CustomerService need to be mockable.&lt;/p&gt;
&lt;p&gt;Whenever you see a passthrough query such as shown above in CustomerService.GetCustomers, it's worth asking, &amp;quot;Can I cut out the middleman?&amp;quot;&lt;/p&gt;
&lt;p&gt;The answer here is &amp;quot;Yes.&amp;quot; The repository is just getting in the way. We know the concrete CustomerService will depend on concrete data. The repository is just an abstraction of that data so we can unit test. We've already determined that if we want to swap out the database, we're going to be rewriting something. Why add to our troubles by essentially &lt;em&gt;writing our CustomerService methods twice&lt;/em&gt;?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt; Inject the mockable data source directly into the service&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If the data source uses an interface, great. If there are multiple data sources, do whatever it takes to make them mockable. But don't use a repository abstraction. It just adds complexity for no gain.&lt;/p&gt;
&lt;h2 id="cutting-out-the-middleman"&gt;Cutting Out the Middleman&lt;/h2&gt;
&lt;p&gt;Here's how our CustomerService example looks with the repository removed, organized by onion layers. These could be different assemblies.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Domain&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Domain.DomainModels
{
    public class Customer
    {
        public int CustomerId { get; set; }
        public string Name { get; set; }
        public int ZipCode { get; set; }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Domain.ServiceInterfaces
{
    public interface ICustomerService
    {
        //Create
        Customer Create(Customer customer);

        //Retrieve
        Customer RetrieveSingleById(int id);
        Customer RetrieveSingleByName(string name);
        List&amp;lt;Customer&amp;gt; RetrieveManyByIds(int[] ids);
        List&amp;lt;Customer&amp;gt; RetrieveManyByPartialName(string partialName);
        List&amp;lt;Customer&amp;gt; RetrieveManyByZipCode(int zipCode, Func&amp;lt;Customer, bool&amp;gt; where);

        //Update
        Customer Update(Customer customer);

        //Delete
        void Delete(int id);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Data.DataModels
{
    public class CustFile
    {
        public int CustId { get; set; }
        public string FullName { get; set; }
    }
    
    public class CustFileExtended
    {
        public int CustNumber { get; set; }
        public int Zip5 { get; set; }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Data.SqlDatabase
{
    public class SqlDbContext : DbContext
    {
        public IDbSet&amp;lt;CustFile&amp;gt; CustFiles { get; set; }
        public IDbSet&amp;lt;CustFileExtended&amp;gt; CustFileExtendeds {get;set;}

        public SqlDbContext(string nameOrConnectionString) : base(nameOrConnectionString) { }
        
        //This constructor is used by Effort in unit testing
        public SqlDbContext(DbConnection existingConnection) : base(existingConnection, true) { }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity&amp;lt;CustFile&amp;gt;()
                .HasKey(a =&amp;gt; a.CustId);

            modelBuilder.Entity&amp;lt;CustFileExtended&amp;gt;()
                .HasKey(a =&amp;gt; a.CustNumber);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Services&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is only showing one method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace Company.Services
{
    public class CustomerService : ICustomerService
    {
        SqlDbContext _context = new EF6Context(&amp;quot;SqlDb&amp;quot;);

        public CustomerService(SqlDbContext context)
        {
            _context = context;
        }

        public List&amp;lt;Customer&amp;gt; RetrieveManyByZipCode(int zipCode, Func&amp;lt;Customer, bool&amp;gt; where)
        {
            var custFileExtendeds = _context.CustFileExtendeds.Where(a =&amp;gt; a.Zip5 == zipCode).ToList();
            return GetCustomers(custFileExtendeds)
                .Where(where).ToList();
        }
        
        // Helpers for mapping
        private List&amp;lt;Customer&amp;gt; GetCustomers(List&amp;lt;CustFile&amp;gt; custFiles)
        {
            List&amp;lt;Customer&amp;gt; customers = new List&amp;lt;Customer&amp;gt;();
            var custFileExtendeds = _context.CustFileExtendeds
                .Where(a =&amp;gt; customers.Select(b =&amp;gt; b.CustomerId).ToList().Contains(a.CustNumber)).ToList();

            customers.AddRange(custFiles.Select(a =&amp;gt;
            {
                var custFileExtended = custFileExtendeds.Single(b =&amp;gt; b.CustNumber == a.CustId);
                return new Customer()
                {
                    CustomerId = a.CustId,
                    Name = a.FullName,
                    ZipCode = custFileExtended.Zip5
                };
            }));

            return customers;
        }

        private List&amp;lt;Customer&amp;gt; GetCustomers(List&amp;lt;CustFileExtended&amp;gt; custFileExtendeds)
        {
            int[] ids = custFileExtendeds.Select(a =&amp;gt; a.CustNumber).ToArray();
            var custFiles = _context.CustFiles.Where(a =&amp;gt; ids.Contains(a.CustId)).ToList();
            return GetCustomers(custFiles);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There are various ways to mock Entity Framework. I like &lt;a href="https://entityframework-effort.net/overview"&gt;Effort&lt;/a&gt; because you don't need to add interfaces to your DbContext, you just need a particular constructor.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;//other usings above, these are the testing dependencies
using Company.Data;
using Company.Data.DataModels;
using Company.Domain.DomainModels;
using Company.Domain.ServiceInterfaces;
using Company.Services;
using Xunit;
using Effort;
using FluentAssertions;

namespace DealingWithData.Tests
{
    public class CustomerService_Should
    {
        SqlDbContext _context;
        ICustomerService _customerService;

        public CustomerService_Should()
        {
            //This is what makes Effort the in-memory database
            _context = new SqlDbContext(DbConnectionFactory.CreateTransient());
            _customerService = new CustomerService(_context);
        }

        ~CustomerService_Should() 
        {
            _context.Dispose();
        }

        [Fact]
        public void Return_a_single_customer_by_id()
        {
            // arrange
            Customer expected = new Customer()
            {
                CustomerId = 1,
                Name = &amp;quot;Herbert&amp;quot;,
                ZipCode = 12345
            };
            // mock the data the service works with
            _context.CustFiles.Add(new CustFile() { CustId = 1, FullName = &amp;quot;Herbert&amp;quot; });
            _context.CustFileExtendeds.Add(new CustFileExtended() { CustNumber = 1, Zip5 = 12345 });
            _context.SaveChanges();

            // act
            var actual = _customerService.RetrieveSingleById(expected.CustomerId);

            // assert
            actual.Should().BeEquivalentTo(expected);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If...when...we have changes in our data sources, we'll have to update the service and the unit tests. That's OK. Before, we'd have been updating repositories and unit tests. This removes the repository pattern dead weight.&lt;/p&gt;
&lt;h2 id="your-data-sources-will-change"&gt;Your Data Sources Will Change...&lt;/h2&gt;
&lt;p&gt;Sometimes radically. Your domain model will change, too, but it shouldn't be driven by the backend data. You should be able to code and unit test without &lt;em&gt;any&lt;/em&gt; concrete dependencies, and it shouldn't be painful.&lt;/p&gt;
&lt;p&gt;Do you really need the Repository pattern? Probably not.&lt;/p&gt;
</description>
      <pubDate>Thu, 13 Feb 2020 15:11:00 -0700</pubDate>
      <link>https://www.softwaremeadows.com/posts/why_the_repository_pattern_fails_for_legacy_database_like_yours_and_wh</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/why_the_repository_pattern_fails_for_legacy_database_like_yours_and_wh</guid>
    </item>
    <item>
      <title>Mock returning a List as IMongoQueryable for unit testing</title>
      <description>&lt;h2 id="the-problem"&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The latest MongoDb driver for .Net doesn't have a way to convert a collection such as List&lt;T&gt; to IMongoQueryable. If the code depends on that interface, it needs to be mocked, but how to set the concrete data?&lt;/p&gt;
&lt;h2 id="the-solution"&gt;The Solution&lt;/h2&gt;
&lt;p&gt;What you'll need to run this sample yourself.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/MongoDB.Driver/"&gt;MongoDb.Driver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/NSubstitute/"&gt;NSubstitute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/xunit/"&gt;xunit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/packages/xunit.runner.visualstudio/"&gt;xunit.runner.visualstudio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's say you've settled on using MongoDb as your NoSQL data store. You write a simple repository pattern with one method to query for any concrete type.&lt;a id="fnref:1" href="#fn:1" class="footnote-ref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;	public interface IMongoRepository&amp;lt;T&amp;gt; where T : class
	{
		public IMongoQueryable&amp;lt;T&amp;gt; QueryAll();
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You also have a simple Customer service that calls the repository&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CustomerService
{
	IMongoRepository&amp;lt;Customer&amp;gt; _customerRepository = null;
	public CustomerService(IMongoRepository&amp;lt;Customer&amp;gt; customerRepository)
	{
		_customerRepository = customerRepository;
	}

	public List&amp;lt;Customer&amp;gt; GetCustomers()
	{
		return _customerRepository.QueryAll().ToList();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, you start writing the following test. But you discover there's no way to get a concrete instance of IMongQueryable&lt;T&gt;. There used to be, but it's legacy code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CustomerService_Should
{
	[Fact]
	public void Return_customers()
	{
		var expected = new List&amp;lt;Customer&amp;gt;() { new Customer() { Id = 1 } };
		var customerRepository = Substitute.For&amp;lt;IMongoRepository&amp;lt;Customer&amp;gt;&amp;gt;();
		
		//return the mocked data. But how to convert the list into IMongoQueryable???

		customerRepository.QueryAll().Returns([argh, what goes here??]);
		var service = new CustomerService(customerRepository);
		var actual = service.GetCustomers();
		Assert.Equal(expected.Count, actual.Count);
		Assert.Equal(expected.First().Id, actual.First().Id);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like me, you probably try all kinds of typecasting before realizing you're always trying to do something impossible. Finally, you find the answer on Stack Overflow. There are two ways to mock up the data, and both make the IMongoQueryable class accept IQueryable.&lt;/p&gt;
&lt;h2 id="using-nsubstitute"&gt;Using NSubstitute&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class CustomerService_Should
{
	[Fact]
	public void Return_customers()
	{
		var expected = new List&amp;lt;Customer&amp;gt;() { new Customer() { Id = 1 } };
		var customerRepository = Substitute.For&amp;lt;IMongoRepository&amp;lt;Customer&amp;gt;&amp;gt;();
		
		//Mock IMongoQueryable to accept IQueryable, enabling just enough of the interface
		//to work
		var expectedQueryable = expected.AsQueryable();
		var mockQueryable = Substitute.For&amp;lt;IMongoQueryable&amp;lt;Customer&amp;gt;&amp;gt;();
		mockQueryable.ElementType.Returns(expectedQueryable.ElementType);
		mockQueryable.Expression.Returns(expectedQueryable.Expression);
		mockQueryable.Provider.Returns(expectedQueryable.Provider);
		mockQueryable.GetEnumerator().Returns(expectedQueryable.GetEnumerator());

		//return the mocked data
		customerRepository.QueryAll().Returns(mockQueryable);
		var service = new CustomerService(customerRepository);
		var actual = service.GetCustomers();
		Assert.Equal(expected.Count, actual.Count);
		Assert.Equal(expected.First().Id, actual.First().Id);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty slick.&lt;/p&gt;
&lt;h2 id="creating-mongoqueryable"&gt;Creating MongoQueryable&lt;T&gt;&lt;/h2&gt;
&lt;p&gt;A simple concrete class that allows setting a List property.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class MongoQueryable&amp;lt;T&amp;gt; : IMongoQueryable&amp;lt;T&amp;gt;
{
	public List&amp;lt;T&amp;gt; MockData { get; set; }

	public Type ElementType =&amp;gt; MockData.AsQueryable().ElementType;

	public Expression Expression =&amp;gt; MockData.AsQueryable().Expression;

	public IQueryProvider Provider =&amp;gt; MockData.AsQueryable().Provider;

	public IEnumerator&amp;lt;T&amp;gt; GetEnumerator() =&amp;gt; MockData.AsQueryable().GetEnumerator();
	IEnumerator IEnumerable.GetEnumerator() =&amp;gt; MockData.AsQueryable().GetEnumerator();

	public QueryableExecutionModel GetExecutionModel() =&amp;gt; throw new NotImplementedException();

	public IAsyncCursor&amp;lt;T&amp;gt; ToCursor(CancellationToken cancellationToken = default) =&amp;gt; throw new NotImplementedException();

	public Task&amp;lt;IAsyncCursor&amp;lt;T&amp;gt;&amp;gt; ToCursorAsync(CancellationToken cancellationToken = default) =&amp;gt; throw new NotImplementedException();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The test.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Fact]
public void Return_customers2()
{
	var expected = new List&amp;lt;Customer&amp;gt;() { new Customer() { Id = 1 } };
	var customerRepository = Substitute.For&amp;lt;IMongoRepository&amp;lt;Customer&amp;gt;&amp;gt;();

	//Mock IMongoQueryable using a class
	var mockQueryable = new MongoQueryable&amp;lt;Customer&amp;gt;();
	mockQueryable.MockData = expected;

	//return the mocked data
	customerRepository.QueryAll().Returns(mockQueryable);
	var service = new CustomerService(customerRepository);
	var actual = service.GetCustomers();
	Assert.Equal(expected.Count, actual.Count);
	Assert.Equal(expected.First().Id, actual.First().Id);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/46035390/unit-testing-with-imongoqueryable"&gt;c# - Unit Testing with IMongoQueryable - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;The comments in Stack Overflow point out that using IMongoQueryable--or IQueryable-- isn't ideal because it tightly couples the code to MongoDb or to a Queryable backend. It might be better to use a truly generic repository and convert to/from MongoDb (or other database) as needed.&lt;a href="#fnref:1" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
      <pubDate>Tue, 28 Jan 2020 17:29:00 -0700</pubDate>
      <link>https://www.softwaremeadows.com/posts/mock_returning_a_list_as_imongoqueryable_for_unit_testing</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/mock_returning_a_list_as_imongoqueryable_for_unit_testing</guid>
    </item>
    <item>
      <title>Git Basics With Visual Studio 2019</title>
      <description>&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/header.png" alt="" /&gt;&lt;/p&gt;
&lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#what-problem(s)-does-git-solve?"&gt;What problem(s) does Git solve?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#how-does-git-basically-work?"&gt;How does Git basically work?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#what%27s-a-typical-daily-flow?"&gt;What's a typical daily flow?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#doing-it-in-visual-studio-2019"&gt;Doing It In Visual Studio 2019&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#create-and-checkout-a-new-branch"&gt;Create and Checkout a New Branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#stage-changes-for-commit"&gt;Stage Changes for Commit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#commit-the-change"&gt;Commit the Change&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#make-a-couple-more-commits"&gt;Make a Couple More Commits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#clean-up-the-commits"&gt;Clean Up the Commits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#checkout-and-synchronize-master"&gt;Checkout and Synchronize Master&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#checkout-and-rebase-feature-onto-master"&gt;Checkout and Rebase Feature Onto Master&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#checkout-and-merge-feature-into-master"&gt;Checkout and Merge Feature Into Master&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#push-changes-to-the-remote-server"&gt;Push Changes to the Remote Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete-the-branch"&gt;Delete the Branch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#common-operations"&gt;Common Operations&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#checkout"&gt;Checkout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#branch"&gt;Branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#add-(stage)"&gt;Add (stage)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#commit"&gt;Commit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#merge"&gt;Merge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rebase-(changes-history)"&gt;Rebase (changes history)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#check-status"&gt;Check Status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#check-history"&gt;Check History&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#revert"&gt;Revert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reset-(changes-history)"&gt;Reset (changes history)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tag"&gt;Tag&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-rules-for-teams"&gt;The Rules For Teams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#solving-common-problems"&gt;Solving Common Problems&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#pull,-merge-and-rebase-conflicts"&gt;Pull, Merge and Rebase Conflicts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#remote-vs-local,-plus-base-and-backup"&gt;Remote vs Local, plus Base and Backup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#last-word"&gt;Last Word&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-problems-does-git-solve"&gt;What problem(s) does Git solve?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Multi-user offline development&lt;/li&gt;
&lt;li&gt;Rapid, dependable branching and merging&lt;/li&gt;
&lt;li&gt;Decentralized version control&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git is a distributed version control system that was originally developed by Linus Torvalds in April 2005 to replace BitKeeper, which was withdrawn from free use due to alleged reverse engineering by SourcePuller creator Andrew Tridgell.&lt;/p&gt;
&lt;p&gt;Torvalds needed a system that could manage the Linux kernel development and scale to hundreds of merges performed in seconds. Git has been maintained by Junio Hamano since July 2005.&lt;/p&gt;
&lt;p&gt;Git is currently the most-used version control system by far. Microsoft recommends Git, has contributed to its development, and hosts the Windows source code using Git--the largest such repository in the world.&lt;/p&gt;
&lt;h2 id="how-does-git-basically-work"&gt;How does Git basically work?&lt;/h2&gt;
&lt;p&gt;A folder, &lt;code&gt;.git&lt;/code&gt;, contains the complete repository for files and folders underneath it. A clone of a repository contains the same history as the original.&lt;/p&gt;
&lt;p&gt;The repository is a file system. Each file is named with an SHA-1 hash. A file contains either the actual content of source code file, or contains a tree of hash file names. In this way, Git maintains references, sometimes called &amp;quot;pointers&amp;quot;--the hash file names--to content.&lt;/p&gt;
&lt;p&gt;There's a file that contains the reference to the root of the solution. From here, all the links to other files can be traced, so this becomes the current state.&lt;/p&gt;
&lt;p&gt;If any file changes, Git creates a new copy of the file with a new hash reference, updates links to it, and creates a new root-level reference. This becomes the new point-in-time version.&lt;/p&gt;
&lt;p&gt;Branches exist by creating a file with the branch name, e.g. &amp;quot;master&amp;quot;, whose content points to a particular root reference file. When people talk about branching in Git being &amp;quot;cheap,&amp;quot; it's because, to branch from another branch, all Git has to do is create another file, e.g. &amp;quot;feature-1,&amp;quot; with the same reference file name.&lt;/p&gt;
&lt;p&gt;If Charlene clones a repository from Blake, all she's doing is making a copy of the .git folder. Let's say Charlene and Blake each make a change to the same file. Each of them will get a &lt;em&gt;different&lt;/em&gt; new reference hash. This is how Git knows to merge files: when it finds a divergence in the tree, it can trace backward in the references to find the common ancestor, then determine the changes via a three-way comparison. Once the differences are resolved, a new version of the file is created with a new reference name.&lt;/p&gt;
&lt;p&gt;The process is exactly the same with repositories located on remote servers. The only difference is that remote repositories are typically &amp;quot;bare,&amp;quot; meaning there's no working folder.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Anyone can create a bare repository on their local file filesystem. It's really just the contents of the .git folder moved to the root level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Remote branch reference information is maintained in a .git folder named &lt;code&gt;remotes&lt;/code&gt;. Where the remotes are located is maintained in a .git config file.&lt;/p&gt;
&lt;p&gt;What's important to understand at this point is that your repository can contain branches for your local work, and branches for remote work. When you &lt;code&gt;fetch&lt;/code&gt; a remote branch, the contents are merged into your local copy of that branch, e.g. &lt;code&gt;origin/master&lt;/code&gt;. You then decide whether to merge those files into your local branch, i.e. &lt;code&gt;master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;When it comes to tracking local changes, there are potentially three versions of the file in play at any one time.&lt;/p&gt;
&lt;p&gt;First, there's the version of the file you're editing. This is the working file.&lt;/p&gt;
&lt;p&gt;Second, there's the version of the file you're going to commit. This is the staged file. (Also called being in the &amp;quot;index&amp;quot;.)&lt;/p&gt;
&lt;p&gt;Third, there's the version of the file since the last commit. This is the repository file.&lt;/p&gt;
&lt;p&gt;How does this look in practice? Let's say the last committed file named Test.txt has one line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-txt"&gt;one
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You edit the file and add a line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-txt"&gt;one
two
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, now your working file is changed, but Git doesn't know about the changes. You add the file to the index via &lt;code&gt;git add Test.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you were to &lt;code&gt;commit&lt;/code&gt; now, the repository file would be updated to match the staged file. But what if you don't commit, and instead add a third line?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-txt"&gt;one
two
three
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you &lt;code&gt;commit&lt;/code&gt;, Git will still only update the repository file with the two lines from the staged file. You'd have to &lt;code&gt;git add&lt;/code&gt; again to stage the file with all three lines.&lt;/p&gt;
&lt;p&gt;This is a very flexible approach, letting you commit only the changes that you want. While I don't cover it in this guide, it's even possible to only commit portions of a file, called &amp;quot;hunks.&amp;quot;&lt;/p&gt;
&lt;h2 id="whats-a-typical-daily-flow"&gt;What's a typical daily flow?&lt;/h2&gt;
&lt;p&gt;Let's assume you've already cloned a repository from a remote server, and have configured your local Git to work easily with that remote. Your typical day will look something like this.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create and 'checkout' a local branch named 'feature-1' from the 'master' branch to work on a feature.
&lt;blockquote&gt;
&lt;p&gt;This is a local feature branch that's not replicated in the remote.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Make a small set of changes to the files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add&lt;/code&gt; the changes to the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Commit&lt;/code&gt; those changes with a short message&lt;/li&gt;
&lt;li&gt;Do this a bunch of times until the feature--or enough of the feature to make available to everyone--is complete (tests run, etc).&lt;/li&gt;
&lt;li&gt;Interactively &lt;code&gt;rebase&lt;/code&gt; those commits, combining them and updating the messages so the changes will be clear in the remote repository history that will be shared with everyone.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Checkout&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch&lt;/li&gt;
&lt;li&gt;Pull (fetch and merge) any changes from the remote's &lt;code&gt;master&lt;/code&gt; branch into your local &lt;code&gt;master&lt;/code&gt; branch.&lt;/li&gt;
&lt;li&gt;Checkout the &lt;code&gt;feature-1&lt;/code&gt; branch.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rebase&lt;/code&gt; onto the &lt;code&gt;master&lt;/code&gt; branch. This makes it seem as if all your changes are also the latest changes.&lt;/li&gt;
&lt;li&gt;Checkout &lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Merge &lt;code&gt;feature-1&lt;/code&gt; into &lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Push&lt;/code&gt; your local &lt;code&gt;master&lt;/code&gt; branch to the remote &lt;code&gt;master&lt;/code&gt; branch.&lt;/li&gt;
&lt;li&gt;Delete your local feature branch&lt;/li&gt;
&lt;li&gt;Create and &lt;code&gt;checkout&lt;/code&gt; a new feature branch and do the whole thing again.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;While this is many discreet steps, the flow soon becomes natural, and the result is a history of changes that's easy to follow.&lt;/p&gt;
&lt;p&gt;Here are the commands for the above flow, which are explained in the &lt;em&gt;Common Operations&lt;/em&gt; section.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git checkout -b feature-1
git add -A
git commit -m 'Try use existing GetAddress feature for GetCustomer'
git commit -m 'Update GetCustomer with new collection'
git commit -m 'Fix broken tests'
git rebase -i master (result is a single commit with message 'Allow git GetCustomer to return addresses')
git checkout master
git pull
git checkout feature-1
git rebase master
git checkout master
git merge feature-1 --no-ff (--no-ff forces the feature to appear clearly as a merge in the log)
git push
git branch -d feature-1
git checkout -b feature-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="doing-it-in-visual-studio-2019"&gt;Doing It In Visual Studio 2019&lt;/h2&gt;
&lt;p&gt;Here are the same operations from above done in Visual Studio 2019. Using Visual Studio 2017 is very similar.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I don't recommend using Visual Studio 2015's Git features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="create-and-checkout-a-new-branch"&gt;Create and Checkout a New Branch&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git checkout -b feature-1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/511d12b20ca34c5481c78b3611939ed1.png" alt="d56bf2ea153b26c70f88de059c3bd2b4.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/252361a8b6ba44668e2f52fa9415ec67.png" alt="1ce43676df42b7b589e5f1e858bde163.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/9090dc7c34ef42e6864be762eeb79133.png" alt="726441de43f69112a3b7d22a0229f89c.png" /&gt;&lt;/p&gt;
&lt;h3 id="stage-changes-for-commit"&gt;Stage Changes for Commit&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git add -A&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: In most cases you won't explicitly stage. You'll just Commit All.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/ae54e77b885b4dc8804fdd082f2c3737.png" alt="8c1abfe61b1708c31429dc860cb16040.png" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void Main(string[] args)
        {
            Console.WriteLine(&amp;quot;Hello Git World!&amp;quot;);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/5ba1bbb4ef08486c8b44d614eaa59462.png" alt="c8e059f6058183635ecdd882c2df4c3d.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/a8ee3bd871464dbbaef94371a6f9e727.png" alt="e588fe8a85594c950331ee7df4fd6849.png" /&gt;&lt;/p&gt;
&lt;h3 id="commit-the-change"&gt;Commit the Change&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git commit -m 'Try use existing GetAddress feature for GetCustomer'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/ae54e77b885b4dc8804fdd082f2c3737.png" alt="8c1abfe61b1708c31429dc860cb16040.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/9f2490f717ed42aab5075d521419a9eb.png" alt="190cbc8f15ebc9a03600d9489a294c8f.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/c1be3950cb3e47da960ce1da8634c872.png" alt="a852e75d75b3907f161341a813946d27.png" /&gt;&lt;/p&gt;
&lt;h3 id="make-a-couple-more-commits"&gt;Make a Couple More Commits&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git commit -m 'Update GetCustomer with new collection&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;git commit -m 'Fix broken tests'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[Note shown]&lt;/p&gt;
&lt;h3 id="clean-up-the-commits"&gt;Clean Up the Commits&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git rebase -i master (result is a single commit with message 'Allow git GetCustomer to return addresses')&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: Visual Studio only gives the option to &amp;quot;squash&amp;quot; the commits. This is what you'll want to do most of the time, anyway.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/511d12b20ca34c5481c78b3611939ed1.png" alt="d56bf2ea153b26c70f88de059c3bd2b4.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/b32b0cab7def4f79a1d3182e58275331.png" alt="011820fcf438a353cbfd9f2cf638c46c.png" /&gt;&lt;/p&gt;
&lt;p&gt;Select the commits to squash, right-click, choose &amp;quot;Squash commits...&amp;quot;&lt;br /&gt;
&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/b160e596e1b44a2c99610fa550574124.png" alt="72e0fc55a21c062f8e00eb9f3af21467.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/7f26fb5ea2fc4feb835d26e460d1c7cb.png" alt="42865a089fe639c93271b70295a68f3d.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: Visual Studio's &amp;quot;Squash Commits&amp;quot; dialog is surprisingly terrible. You effectively can't edit the text, because A) there's no way to create a soft return, and B) you can't paste more than the top line of copied text.&lt;/p&gt;
&lt;p&gt;Until it's better, I recommend using the command line for squashing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="checkout-and-synchronize-master"&gt;Checkout and Synchronize Master&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git checkout master&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;git pull&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/4247d340e64547e18e9c2f029268e8ca.png" alt="9d26612a714f0fa28863d54bbbf77b66.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/0a90d19c67d348adb50c41dad5d8cde1.png" alt="35f579bba4a8184b23c869eba0daf1f5.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/17ecfcd77a034a1e9bbaf058ea439eb2.png" alt="a21d807d67769575d76026ed837b8d39.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/d48f77d71573440cb0b8bc68bbff52c0.png" alt="2d69bff4e05bca1b78988e9a5c2d95ac.png" /&gt;&lt;/p&gt;
&lt;h3 id="checkout-and-rebase-feature-onto-master"&gt;Checkout and Rebase Feature Onto Master&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git checkout feature-1&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;git rebase master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/eefbbc82a8f849e9aec5430520006621.png" alt="e32a0e0f368f590511a459b46d8b9e10.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/03f2a83e4da64e718be250ac7cb30595.png" alt="4dfbf5cbdba3900185bcc5d65e3583e1.png" /&gt;&lt;/p&gt;
&lt;h3 id="checkout-and-merge-feature-into-master"&gt;Checkout and Merge Feature Into Master&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git checkout master&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;git merge feature-1 --no-ff&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/4247d340e64547e18e9c2f029268e8ca.png" alt="9d26612a714f0fa28863d54bbbf77b66.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/2d68e0ea94714545bace10749edd9173.png" alt="081e72e7927dc10242f22af4b4e4b72a.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/6b2421e1e0fd414fa8c91f63facbe339.png" alt="3846c6938dca5a4f98eabe249d05c7f5.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: Visual Studio doesn't appear to have a &lt;code&gt;--no-ff&lt;/code&gt; option. Because of the value to a good history, I recommend doing the final commit at the command line using an alias.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: It possible to set Git to always use &lt;code&gt;--no-ff&lt;/code&gt; via the &lt;code&gt;merge.ff false&lt;/code&gt; option. However, this will only work in your local instance unless a repository-specific config file is used and committed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's how that commit looks after using &lt;code&gt;--no-ff&lt;/code&gt; at the command line. Notice how much clearer it is in both the command window and Visual Studio&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/33f4eacd08d546bf8161ea96a07bf0c6.png" alt="50591bd7eef98c1ca4a6ce8fe50b7de8.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/a13c3fa8a4174de6aae0065741548eed.png" alt="27def2246530c8a31c8a548c1b32f05b.png" /&gt;&lt;/p&gt;
&lt;h3 id="push-changes-to-the-remote-server"&gt;Push Changes to the Remote Server&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/2f17ebf42952430fa19c9151a0ea8594.png" alt="16c89e011e40d24dd6384644f134357c.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/af3613bb2a134f4f85d0fc42b5d5e52a.png" alt="14db281f2c515fd6c663d0249abf073b.png" /&gt;&lt;/p&gt;
&lt;h3 id="delete-the-branch"&gt;Delete the Branch&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git branch -d feature-1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/f0ea4f860eaa4cd98c5c814362fa53d9.png" alt="6bd13d905ef6da80cf15c4c379bf22c7.png" /&gt;&lt;/p&gt;
&lt;h2 id="common-operations"&gt;Common Operations&lt;/h2&gt;
&lt;h3 id="checkout"&gt;Checkout&lt;/h3&gt;
&lt;p&gt;Checkout means to set your working folder to a particular point in time. You're always choosing a reference hash of a &amp;quot;root&amp;quot;. However, you can use branch and tag names because they &amp;quot;point&amp;quot; to a particular reference.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git checkout master
git checkout feature-1
git checkout origin\master
git checkout head
git checkout head~3
git checkout v2.35.9
git checkout f935ea4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="branch"&gt;Branch&lt;/h3&gt;
&lt;p&gt;With the above information about how Git works, you should now understand what people mean by &amp;quot;a branch is a pointer to a reference.&amp;quot;&lt;/p&gt;
&lt;p&gt;You may not use the branch command to create a branch very often. Typically, you'll create and checkout a branch in a single step using this command:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout -b feature-1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;That single command runs these two commands:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git branch master feature-1
git checkout feature-1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other branch commands.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;branch -d feature-1
branch -D featue-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="add-stage"&gt;Add (stage)&lt;/h3&gt;
&lt;p&gt;Adds changes to the index, to be committed.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git add -A
git add Test.txt
git add Models/Customer.cs
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="commit"&gt;Commit&lt;/h3&gt;
&lt;p&gt;Commits staged changes (in the index) to the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;commit
commit -m 'Allow GetCustomer to show addresses'
commit -amend (changes history)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You'll often amend a commit if, for example, you realized you forgot to add a file, or mispelled something in the commit message.&lt;/p&gt;
&lt;p&gt;For example, assume this history:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;1234567 Fix spelling erors
1234568 Fix my wrong spelling fix
1234569 Add marketing copy
123456A Remove temporary files
123456B Add history file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After committing &amp;quot;Fix spelling erors&amp;quot;, you realize you not only forgot to add the latest spelling file, but also mispelled &amp;quot;errors.&amp;quot; You'd execute something like&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git add spelling.dat
git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The editor would open, and you could either change the message or--more likely--just close the editor. Here's how the result might look.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;afgec73 Fix spelling errors
1234568 Fix my wrong spelling fix
1234569 Add marketing copy
123456A Remove temporary files
123456B Add history file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here's the important thing to notice: &lt;strong&gt;The &amp;quot;fix spelling errors&amp;quot; commit's ref hash has changed.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="merge"&gt;Merge&lt;/h3&gt;
&lt;p&gt;Merges changes from another branch into the current branch. You must have the destination branch checked out. For example, in order to merge the changes from the &lt;code&gt;feature-1&lt;/code&gt; branch into the &lt;code&gt;master&lt;/code&gt; branch, you must first be in the &lt;code&gt;master&lt;/code&gt; branch.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git checkout master
git merge feature-1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="rebase-changes-history"&gt;Rebase (changes history)&lt;/h3&gt;
&lt;p&gt;Rebase has two main uses. The first is to modify a set of commits, usually combining (&amp;quot;squashing&amp;quot;) them, so that the resulting commits are &amp;quot;the way it should have been&amp;quot;. For example, let's say you have these five commits in a local feature branch.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;1234567 Fix spelling errors
1234568 Fix my wrong spelling fix
1234569 Add marketing copy
123456A Remove temporary files
123456B Add history file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using interactive rebase, you could revise this to two commits:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;987ABCD Fix spelling errors
987AGF2 Add history file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the original file reference hashes were not reused. &lt;em&gt;New&lt;/em&gt; commits were created. It's as if these new commits had always been the &lt;em&gt;only&lt;/em&gt; commits.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, those other five commits still exist in the reflog if needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git rebase -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is a screen that guides you through the changes.&lt;/p&gt;
&lt;p&gt;The second use is making your branch's commits seem like they were just done so that they appear as the latest commits on another branch. For example, you're working on your feature branch and have cleaned up your commits. Now you want to merge your changes into master, so you checkout master and pull.&lt;/p&gt;
&lt;p&gt;The problem is, while you were working, someone else committed changes to master. So now your changes are &lt;em&gt;behind&lt;/em&gt; that other person's. If you were to merge your changes, then view history, they'd be kind of jumbled in. Instead, you want your changes to appear after the other person's.&lt;/p&gt;
&lt;p&gt;To do that, you rebase your changes onto master. Git will temporarily reset your branch to when you originally branched, merge the latest changes from master into your branch (making them identical), then &lt;em&gt;replay&lt;/em&gt; your commits on top of this history. Each of your commits is treated as new, so it gets a new reference hash.&lt;/p&gt;
&lt;p&gt;The command sequence to do this is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git checkout master
git pull
git checout feature-1
git rebase master
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;There's a chance you'll need to resolve conflicts between your changes and the other persons.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="check-status"&gt;Check Status&lt;/h3&gt;
&lt;p&gt;Shows which files are modified, new, or deleted. Also shows which files are staged.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="check-history"&gt;Check History&lt;/h3&gt;
&lt;p&gt;Shows information about commits.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git log
git log --graph --oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="revert"&gt;Revert&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;revert&lt;/code&gt; command &amp;quot;unapplies&amp;quot; a set of commits that appear after a commit in history, and creates a new commit at the top. Let's say you have this history.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;6293daae maybe ok 
fec62970 mistake 2
96ca7600 mistake 1
bac6d253 working fine
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;// reverts the top three commits
git revert 96ca7600^..6293daae


// reverts the middle two commits
git revert 96ca7600^..fec62970
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each commit that's reverted gets its own new commit. After each reversion, you need to enter &lt;code&gt;git revert --continue&lt;/code&gt; until all reversions are complete.&lt;/p&gt;
&lt;h3 id="reset-changes-history"&gt;Reset (changes history)&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;reset&lt;/code&gt; command undoes a set of commits starting at the latest. It does &lt;em&gt;not&lt;/em&gt; create a new commit. It effectively throws away the changes.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Basically, the HEAD file is updated to point to the given ref hash. In the example below, HEAD would change from 6293daae to bac6d253. The only other question is whether the commit changes are retained in some way.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given this history,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;6293daae maybe ok 
fec62970 mistake 2
96ca7600 mistake 1
bac6d253 working fine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are the common ways to use the command to remove the top three commits.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset bac6d253&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The default command executes in --mixed mode. The index is reset, but the working folder is left alone. This means any changes are ready to add and commit.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset bac6d253 --soft&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The index is &lt;em&gt;not&lt;/em&gt; reset, nor is the working folder. Any changes are already added and ready to commit.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset bac6d253 --hard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Both the index and working folder are reset. All changes are lost.&lt;/p&gt;
&lt;h3 id="tag"&gt;Tag&lt;/h3&gt;
&lt;p&gt;There are two kinds of tags: annotated and lightweight. Annotated tags are meant for release (such as pushing to the remote repository), while lightweight tags are good for local use and cannot be pushed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Personally, I only use annotated tags.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;List all tags&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create a lightweight tag at the HEAD&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag temp1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Create annotated tag at the HEAD, with a message of the same text&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag -a v1.2.4 -m v1.2.4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Delete a tag&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag -d v1.2.4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Force an existing tag onto a different commit&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git tag -a -f 63fac95&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="the-rules-for-teams"&gt;The Rules For Teams&lt;/h2&gt;
&lt;p&gt;Git is powerful, and one of its powers comes with a risk. That is the power to &amp;quot;rewrite history.&amp;quot; What this means in practice is that a user could push changes to a remote repository that conflict with existing log entries others have already pulled. I show an example below, but first here are the rules.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Don't push changes from &lt;code&gt;rebase&lt;/code&gt;,&lt;code&gt;revert&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt; if you've previously pushed the affected commits.&lt;/li&gt;
&lt;li&gt;Rebase features onto master, then merge features into master.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;First, here's an example of an easy mistake to make. The user is on the master branch, commits locally, pushes to the remote, then amends the commit and pushes again.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;git commit -m &amp;quot;All done!&amp;quot;
git log --graph --oneline
  afea725 All done!
  7c934ag Pass all tests

git push
--Forgot to add some files!
git add --all
git commit --amend -m &amp;quot;All done!&amp;quot; &amp;lt;= gets a warning
git pull &amp;lt;= thinks this is the right thing to do, but it isn't
git commit --amend -m &amp;quot;All done!&amp;quot;
git log --graph --oneline
  024ag7d All done!
  7c934ag Pass all tests

git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that the &amp;quot;All done!&amp;quot; commit's reference hash is different after being amended. The problem above would be compounded if the user didn't amend the commit for awhile.&lt;/p&gt;
&lt;p&gt;What if developer B pulls from the server after user A's first push? B will have a history that includes ref &lt;code&gt;afea725&lt;/code&gt;. In the meantime, the A amends and pushes. Now B pulls. Does her ref &lt;code&gt;afea725&lt;/code&gt; magically disappear? No. She ends up with something like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-git"&gt;  024ag7d All done!
  afea725 All done!
  7c934ag Pass all tests
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, it could be worse. User A could force the amended commit. This will lead B to getting an even worse history.&lt;/p&gt;
&lt;p&gt;The problems arising from using the other commands that change history are similar.&lt;/p&gt;
&lt;p&gt;Second, if a user doesn't rebase features onto master, then this leads to an unclear history where the branch the user just finished and is pushing to the remote server looks as if it was done a week ago (or whatever). That's because, according to the history, it has. But that's not what the user intended.&lt;/p&gt;
&lt;h2 id="solving-common-problems"&gt;Solving Common Problems&lt;/h2&gt;
&lt;h3 id="pull-merge-and-rebase-conflicts"&gt;Pull, Merge and Rebase Conflicts&lt;/h3&gt;
&lt;p&gt;The first time I encountered a merge conflict, I was utterly &lt;a href="https://www.dictionary.com/browse/flummox"&gt;flummoxed&lt;/a&gt;. I didn't understand what to do, and I was definitely confused by whether my local files were actually &amp;quot;local&amp;quot; or &amp;quot;remote&amp;quot;.&lt;/p&gt;
&lt;p&gt;Here's a message from trying to push changes that conflict with local changes.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/dab337fda0444befb3c250f0da10859d.png" alt="69d8820294e311fe814870be03de14d8.png" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-txt"&gt;Error: hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

Error encountered while pushing to the remote repository: rejected Updates were rejected because the remote contains work that you do not have locally. This is usually caused by another repository pushing to the same ref. You may want to first integrate the remote changes before pushing again.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, we do what we're told and try to pull.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/61e153c157ba4c1f9b3b51088b2ba0a2.png" alt="d7d0d0f7dddc3c2971ccb392e65b6910.png" /&gt;&lt;/p&gt;
&lt;p&gt;We're now in the midst of resolving a merge conflict. At this point we have two options: resolve the conflict, or abort. If we abort, it's as if the pull never happened.&lt;/p&gt;
&lt;p&gt;To visually merge the files, click &amp;quot;Conflicts: 1&amp;quot;, then select a file that has a conflict.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/bd246b9b8fdf4a94a435c0e7496d965a.png" alt="a7b756d8efc2495e6ea4f652b111ee50.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/342e36015852460fb51eb06d640f1e5c.png" alt="47b2758f25fe31fa6f8fe2659855627c.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/2d8b7f0aeed247b79d3a1769b0cbf4d9.png" alt="a76231cdf708eb9070d7fb8dbef685d7.png" /&gt;&lt;/p&gt;
&lt;p&gt;There are several options for comparing and merging files. The one we'll look at is the three-way merge. Click Merge. This will run whatever merge tool you've configured Git to use.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I've used KDiff3 for years because it's very clear about where the conflict is. However, since this article is about using Visual Studio, that's what I'll demonstrate. It looks like Microsoft has improved Visual Studio's diff/merge quite a bit, which is good!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/3e369ebec9594156b5b8bef6a401dfa0.png" alt="7ac96fb74ef0e5e5cb024288e58fb1bd.png" /&gt;&lt;/p&gt;
&lt;p&gt;Choose which version you want to keep, the left or right &lt;em&gt;or both&lt;/em&gt;. You can also type directly into the base. We'll take the left (our) change, Accept Merge, and close the editor.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/190f0d2bf8904fa6bb3fc9326b3fcc1f.png" alt="7fa4131d5f8f086fd3a2177b401ac653.png" /&gt;&lt;/p&gt;
&lt;p&gt;Finally, commit the merge.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/81d0453964fa4dda899377a83cf64716.png" alt="071afeda9a3ac3898e7b02244d7daabb.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/aa4d8e8e4e4e46fc9b897fbb9c8c9cfc.png" alt="fec0a2bf91ee0811825e6fabbbf8e6d7.png" /&gt;&lt;/p&gt;
&lt;p&gt;And, you're ready to push.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019/images/6dbad3fbd9794386b4012289003a7c30.png" alt="382ecb4efcec7315a3c9dbfd8e394526.png" /&gt;&lt;/p&gt;
&lt;h3 id="remote-vs-local-plus-base-and-backup"&gt;Remote vs Local, plus Base and Backup&lt;/h3&gt;
&lt;p&gt;The &amp;quot;base&amp;quot; file is easy to understand; it's the version that's common to both of the changed versions prior to when they diverged.&lt;/p&gt;
&lt;p&gt;If you're dealing with a merge conflict from another developer, that's easy, too. The Remote will be their file, and Local will be yours.&lt;/p&gt;
&lt;p&gt;But what if there's a conflict locally between two branches? For example, what if you&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Branch from master into feature, commit a change there&lt;/li&gt;
&lt;li&gt;Go back to master and commit a change there&lt;/li&gt;
&lt;li&gt;Try to merge feature into master OR rebase feature onto master&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Visual Studio makes this pretty easy by using clearer terminology.&lt;/p&gt;
&lt;p&gt;In the case of &lt;strong&gt;Merge&lt;/strong&gt;, the &lt;code&gt;master&lt;/code&gt; branch file is the Target, and the &lt;code&gt;feature&lt;/code&gt; file is the Source. If you used the command &lt;code&gt;git mergetool&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; would be LOCAL and &lt;code&gt;feature&lt;/code&gt; would be REMOTE.&lt;/p&gt;
&lt;p&gt;In the case of &lt;strong&gt;Rebase&lt;/strong&gt;, it's the same: 'master&lt;code&gt;is Target/LOCAL, and&lt;/code&gt;feature` is Source/REMOTE.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Merge vs Rebase terminology is what confuses people, so let's repeat it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If I'm on &lt;code&gt;master&lt;/code&gt; branch and &lt;strong&gt;merge&lt;/strong&gt;, &lt;code&gt;master&lt;/code&gt; is Target/LOCAL&lt;/li&gt;
&lt;li&gt;If I'm on &lt;code&gt;feature&lt;/code&gt; branch and &lt;strong&gt;rebase&lt;/strong&gt;, &lt;code&gt;master&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; Target/LOCAL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The target is whichever branch you're merging &lt;em&gt;into&lt;/em&gt;, or rebasing &lt;em&gt;onto&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If Git is configured to keep backups of the file before merging begins (mergetool.keepBackup = true), after the merge is committed there will be files with a .backup extension. These need to be cleaned up.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clean -f&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I suggest setting the config file's mergetool.keepBackup to false. Several times I've accidentally added the backup files to a commit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="last-word"&gt;Last Word&lt;/h2&gt;
&lt;p&gt;Git's powerful, at times confusing, always complex, and frequently complicated. Hopefully this article has given you a solid foundation in Git's basics.&lt;/p&gt;
</description>
      <pubDate>Sun, 29 Dec 2019 19:30:00 -0700</pubDate>
      <link>https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/git_basics_with_visual_studio_2019</guid>
    </item>
    <item>
      <title>TFS/Azure DevOps: Building and Releasing Git Branches, A Simple Example</title>
      <description>&lt;h2 id="contents"&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#the-situation"&gt;The Situation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#implementation"&gt;Implementation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#git"&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tfs-build"&gt;TFS Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tfs-release"&gt;TFS Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code-freeze"&gt;Code Freeze&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-situation"&gt;The Situation&lt;/h2&gt;
&lt;p&gt;The development teams run on a two-week release cycle. The final three days of the cycle they are in code freeze. Code is deployed to two environments: Test and Production.&lt;/p&gt;
&lt;p&gt;During code freeze:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;At the start, all repos are built and released to Test. This is the production code.&lt;/li&gt;
&lt;li&gt;Newly developed code must be committed to the repository and built, but it must &lt;em&gt;not&lt;/em&gt; be released to Test.&lt;/li&gt;
&lt;li&gt;At the end, all production code is deployed to Production, and newly developed code is deployed to Test.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, the teams want to have just one build and one deployement definition for each solution.&lt;/p&gt;
&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;
&lt;h3 id="git"&gt;Git&lt;/h3&gt;
&lt;p&gt;Git is configured with two long-lived branches: master and development.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Developers always work against the development branch, pushing their local, short-lived feature branches.&lt;/li&gt;
&lt;li&gt;At code freeze, development is merged into master.&lt;/li&gt;
&lt;li&gt;If there are emergency production deployments, ideally they're made first to deployment and then to master. If they're made directly to master then the changes need to be merged into development (or, ideally, development is rebased onto master)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="tfs-build"&gt;TFS Build&lt;/h3&gt;
&lt;p&gt;The build definition is configured with Triggers, specifically Branch filters for both master and development branches. Continuous Integration is enabled.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_08-55-31.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;This allows commits to both development and master branches to trigger the build.&lt;/p&gt;
&lt;h3 id="tfs-release"&gt;TFS Release&lt;/h3&gt;
&lt;p&gt;The deployment definition is configured in the following way:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pipeline&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-18-00.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Artifacts&lt;/strong&gt;&lt;br /&gt;
There's a single artifact with a Source type of Build. The Source is the build definition.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-18-03.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;Continuous deployment is enabled, and both branches are allowed.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-18-55.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Environments&lt;/strong&gt;&lt;br /&gt;
Both environments use the After release trigger.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Test Environment&lt;/em&gt;&lt;br /&gt;
The artifact filters include both branches&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-21-51.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;In the sample, a Copy Files task is used to move the binaries to their release folder. While not required for the solution, it demonstrates using variables to create release subfolders. In this case, folders for branch and build number are created. Also note the Overwrite and Flatten Folders checkboxes.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-43-07.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Production Environment&lt;/em&gt;&lt;br /&gt;
The differences between this and the Test environment are&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only the master branch is included in the artifact filters&lt;/li&gt;
&lt;li&gt;Approvers are added&lt;/li&gt;
&lt;li&gt;Only the latest build is deployed upon approval&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-45-58.png" alt="" /&gt;&lt;br /&gt;
&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-46-23.png" alt="" /&gt;&lt;br /&gt;
&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_09-48-16.png" alt="" /&gt;&lt;/p&gt;
&lt;h3 id="code-freeze"&gt;Code Freeze&lt;/h3&gt;
&lt;p&gt;What has to happen during the code freeze?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Development branch commits don't deploy. That's it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There are at least two ways to prevent development branch deployments during code freeze.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Add a build tag using a custom task that checks for the presense of a particular file. A custom build task would be used for this.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sorry, I don't have an example of this. But I've seen it done in a real-world environment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use a Gated release. For example, check a web service endpoint. If it fails to return, you're in code freeze and the gate fails.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Recommendation: Stick with build tags&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The disadvantage to tagging builds is that the custom task needs to be added to each build definition. The advantage is that the tag is part of the artifact trigger.&lt;/p&gt;
&lt;p&gt;The disadvantage to gates is that there's a required timeout period of at-minimum 6 minutes before the gate fails. The advantage is that build definitions don't need to create tags.&lt;/p&gt;
&lt;p&gt;REST API Gate Sample&lt;br /&gt;
&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_12-22-08.png" alt="" /&gt;&lt;br /&gt;
&lt;img src="https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example/ScreenCap_2019-12-11_12-22-35.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;Web API Endpoint Sample&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;   public class InCodeFreezeController : ApiController
    {
        public IHttpActionResult Get()
        {
            //IsInCodeFreeze checks some condition. Could be the same file-existence
            //check that's used for tagging today.
            //Not ideal, but simpler for TFS Gate to just fail the request
            if (IsInCodeFreeze)
            {
                return BadRequest();
            }
            return Ok();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Thu, 12 Dec 2019 18:34:00 -0700</pubDate>
      <link>https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/tfs_azure_devops__building_and_releasing_git_branches,_a_simple_example</guid>
    </item>
    <item>
      <title>Who Are You Coding For?</title>
      <description>&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/who_are_you_coding_for_/images/The_bones_of_a_bridge.jpg" alt="" /&gt;&lt;/p&gt;
&lt;h2 id="the-lesson"&gt;The Lesson&lt;/h2&gt;
&lt;p&gt;Consider this brief, hypothetical exchange between two developers, maybe in a meeting where others are present.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Developer 1&lt;/strong&gt;: &amp;quot;...so, I solved the problem this way. This causes e.Data to overwrite the previous line.&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;bool overwrite = e.Data.Contains(&amp;quot;.....&amp;quot;);

WriteLog(e.Data, overwrite);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Developer 2&lt;/strong&gt;: &amp;quot;You know you could just include the condition in the WriteLog call. You don't need to go to the trouble of  setting a variable.&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;WriteLog(e.Data, e.Data.Contains(&amp;quot;.....&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Developer 1&lt;/strong&gt;: &amp;quot;Sure. So, why did I?&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Developer 2&lt;/strong&gt;: &amp;quot;Huh?&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Developer 1&lt;/strong&gt;: &amp;quot;Why did I use a variable?&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Developer 2&lt;/strong&gt;: &amp;quot;I don't know.&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Developer 1&lt;/strong&gt;: &amp;quot;Because I'm not coding for me today. I'm coding for other developers, and my future self. I want it to be as easy for them as possible to understand what this code is doing.&amp;quot;&lt;/p&gt;
&lt;h2 id="why-i-wrote-this"&gt;Why I wrote this&lt;/h2&gt;
&lt;p&gt;My grandfather was once desribed as a bridge-builder. Even if he were (metaphorically) crossing a river just once, he'd build a bridge for whoever came after him.&lt;/p&gt;
&lt;p&gt;Think about this as you make coding, architectural, and documentation decisions. What you do will affect someone in the future. Are you focused on finishing now, as fast as possible? Or crafting your code so that someone thanks you later on.&lt;/p&gt;
&lt;p&gt;Who are you coding for?&lt;/p&gt;
</description>
      <pubDate>Sun, 20 Oct 2019 18:36:00 -0600</pubDate>
      <link>https://www.softwaremeadows.com/posts/who_are_you_coding_for_</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/who_are_you_coding_for_</guid>
    </item>
    <item>
      <title>The ViewService Pattern: Especially Good For Windows Forms</title>
      <description>&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/the_viewservice_pattern__especially_good_for_windows_forms/images/form.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;Windows Form development is still happening, is fast, and is reasonably easy to understand how to get started with. It's event-driven and hasn't changed much since Visual Basic. You drag controls onto a canvas, double-click the controls to open their event methods, and write what's supposed to happen.&lt;/p&gt;
&lt;p&gt;Thus, Frankenstein's monster was born.&lt;/p&gt;
&lt;p&gt;I'm taming the monster with a pattern I'm calling the ViewService. I won't create a Gang of Four class diagram, but basically a ViewService is a way of separating the code that manages ViewModels, and is a useful approach in Windows Forms. It's directly analagous to domain services and models.&lt;/p&gt;
&lt;p&gt;How often have you written or maintained code that looks like this? (note this is pseudocoding, not actual code.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class MainForm
{
    void buttonLoadData(object sender, EventArgs e)
    {
        var cn = new Connection(_connString);
        var cmd = new Command(cn, &amp;quot;select a.*, b.* from Customer a join Order b on a.CustomerId = b.CustomerId&amp;quot;);
        var reader = cmd.ReadResults();
        until (reader.Eof)
        {
            var co = ConvertReaderToCustomerOrder(reader.Read());
            grid1.Row.Add(new Row(co.Name, co.Zip);
            AddOrdersToGridRow(grid1.Rows[grid1.Rows.Length-1], co)
            if (co.Type = 1) { grid1.Rows[grid1.Rows.Length-1].BackgroundColor = Blue;}
            else if (co.Type = 3) { grid1.Rows[grid1.Rows.Length-1].BackgroundColor = Orange;}
        }
        
    }
    
    void AddOrdersToGridRows(Row row, CustomerOrder order, Connection cn)
    {
        foreach (var orderitem in order.Orders)
        {
            var cmd = new Command();
            cmd.Connection = cn;
            cmd.CommandText = String.Format (&amp;quot;select * from lineitems where OrderId = %1&amp;quot;,  orderitem.OrderId);
            var items = ToLineItems(cmd.ExecuteQuery());
            row[&amp;quot;Items&amp;quot;] = AddItemsToGrid(items, row);
            if (order.Type = 3 and items.Count() &amp;gt; 15) {row.BackgroundColor = Red;}
        }
        CheckIfMoreOrdersHaveArrivedAndPrintThem();
        
    }
    
    void buttonRefreshData(object sender, EventArgs e)
    {
        buttonLoadData(sender, e);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problems with the above code could occupy us for awhile, and they add up to one word: complication.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Events are doing too many things&lt;/li&gt;
&lt;li&gt;Events are called directly&lt;/li&gt;
&lt;li&gt;Tight coupling&lt;/li&gt;
&lt;li&gt;Inconsistent naming and coding style&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here's how I recommend clearing up this kind of code by applying the ViewService pattern.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Group form events together&lt;/li&gt;
&lt;li&gt;Group together methods that only apply to this form&lt;/li&gt;
&lt;li&gt;Group methods that could apply to a &lt;strong&gt;replacement&lt;/strong&gt; form together, potentially into a service&lt;/li&gt;
&lt;li&gt;Form events present data, or call a method to preserve data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's apply these steps to the above.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The code below is pretty sparse and incomplete. The goal is to give you the idea of what to do, not provide a full-fledged implementation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="group-form-events-and-methods"&gt;Group form events and methods&lt;/h2&gt;
&lt;p&gt;This is organizational, and clarifies what the &lt;em&gt;user&lt;/em&gt; is doing vs what the &lt;em&gt;developer&lt;/em&gt; is doing. (Methods collapsed for clarity.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
+ void AddOrdersToGridRows(Row row, CustomerOrder order, Connection cn)...

#region &amp;quot;Control Events&amp;quot;

+ void buttonLoadData(object sender, EventArgs e)...
+ void buttonRefreshData(object sender, EventArgs e)...

#endregion

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="better-methods-and-names-and-events-call-custom-methods-instead-of-being-treated-as-custom-methods"&gt;Better methods and names, and events &lt;em&gt;call&lt;/em&gt; custom methods instead of being &lt;em&gt;treated&lt;/em&gt; as custom methods&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;class MainForm
{
    List&amp;lt;CustomerOrderView&amp;gt; _customerOrders = new List&amp;lt;CustomerOrderView&amp;gt;();
    
    + void GetData()...
    + void LoadControls()
    
    void buttonLoadData(object sender, EventArgs e)
    {
        GetData();
        LoadControls();
    }
    void buttonCancel(object sender, EventArgs e)
    {
        LoadControls();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Already, we're gaining clarity.&lt;/p&gt;
&lt;h2 id="separate-the-data-calls-into-a-viewservice"&gt;Separate the data calls into a ViewService&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Imagine the ViewService is going to be resued in a web application. That means it doesn't accept or process form controls, and is UI agnostic.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is the same Dependency Injection pattern used in web applications. The difference is that CustomerOrderViewService isn't a domain service, it's specific to this view of the data.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;
class MainForm 
{
    ICustomerOrderViewService _customerOrderViewService = null;
    List&amp;lt;CustomerOrderView&amp;gt; _customerOrders = new List&amp;lt;CustomerOrderView&amp;gt;();

    
    + void MainForm(ICustomerOrderViewService)...
    
    void GetData()
    {
        _customerOrders = _customerOrderViewService.Get(txtCustomerId.Text);
    }
    
    void LoadControls()
    {
        if (_customerOrders == null) { GetData(); }
        gridOrders.DataSource = _customerOrders;
    }

}

//These two classes would be in separate files, and *could* be in a separate namespace
//to emphasize the decoupling.

class CustomerOrderViewService: ICustomerOrderViewService
{
    ICustomerOrderService _customerOrderService = null;
    
    + public CustomerOrderViewService(ICustomerOrderService _customerOrderService)...
    

    public List&amp;lt;CustomerOrderView&amp;gt; Get(string customerId)
    {
        //This is the call to the *domain service*. It might call the database directly, or might in turn call a web api.
        
        //Returns type CustomerOrder
        var customerOrders = _customerOrderService.GetOrdersByCustomer(string customerId);
        
        //Mapping
        return customerOrders.Select(a =&amp;gt; a.ToCustomerOrderView());
    }
    
}

class static CustomerOrderViewServiceHelpers
{
    public static ToCustomerOrderView (this CustomerOrder customerOrder)
    {
        return new CustomerOrderView()
        {
            Name = customerOrder.Name,
            CustomerType = customerOrder.CustomerType,
            etc....
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="the-happy-wrap-up"&gt;The Happy Wrap Up&lt;/h2&gt;
&lt;p&gt;By applying the ViewService pattern, we can separate Windows Form code into cleaner areas of concern, making our code clear, testable, maintainable and replaceable.&lt;/p&gt;
</description>
      <pubDate>Sun, 13 Oct 2019 12:03:00 -0600</pubDate>
      <link>https://www.softwaremeadows.com/posts/the_viewservice_pattern__especially_good_for_windows_forms</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/the_viewservice_pattern__especially_good_for_windows_forms</guid>
    </item>
    <item>
      <title>Most of Us Developers Aren't Smart</title>
      <description>&lt;p&gt;&lt;img src="https://www.softwaremeadows.com/posts/most_of_us_developers_arent_smart/images/light-bulbs-styled-after-felix-gonzalez-torres.png" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;Most of us developers think we're smart. But we aren't smart. We're clever.&lt;/p&gt;
&lt;p&gt;And confused.&lt;/p&gt;
&lt;p&gt;You can easily prove this by looking at our code. Specifically, by answering these questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;How many layers of indirection are there?&lt;/li&gt;
&lt;li&gt;How many abstractions of abstractions are there?&lt;/li&gt;
&lt;li&gt;How many different things are our methods doing?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Combined, these reveal how complicated a set of code is.&lt;/p&gt;
&lt;p&gt;What we do as developers is complex. There are lots of little moving parts that all need to work together.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Complex: composed of many interconnected parts; compound; composite&lt;a id="fnref:1" href="#fn:1" class="footnote-ref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Complicated: difficult to analyze, understand, explain, etc.&lt;a id="fnref:2" href="#fn:2" class="footnote-ref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because we're clever, we think we understand how to manage this complexity. But we don't. We're confused by it. So, instead of making the complex clear, we complicate it. We add stuff that makes those moving parts harder to understand (over-use of indirection and abstraction), and harder to work together (method multi-responsibility).&lt;/p&gt;
&lt;p&gt;No one likes to hear this or face it in themselves. But we face it too often when supporting others' code. It comes with that little, internal question, &amp;quot;Couldn't this be easier?&amp;quot;&lt;/p&gt;
&lt;p&gt;So, what do we do?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First&lt;/strong&gt;, decide that &amp;quot;we&amp;quot; applies to &amp;quot;you.&amp;quot; It's better to start with this assumption because it leads to learning rather than avoidance. If I insist I'm smart, I won't make the effort to learn better--thus, not smart. But if I insist I can be better, no matter how good I am, then the path to improvement and away from stagnation opens long and wide.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second&lt;/strong&gt;, find examples of complex code that isn't complicated. Open source projects coming out of Microsoft and Google are good starting points.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Third&lt;/strong&gt;, Read about and apply the principles behind uncomplicating code. Three of these are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/SOLID"&gt;SOLID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"&gt;DRY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it"&gt;YAGNI&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, be guided by four overarching principles in your architecture and coding. Make your code...&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clear&lt;/li&gt;
&lt;li&gt;Maintainable&lt;/li&gt;
&lt;li&gt;Testable&lt;/li&gt;
&lt;li&gt;Replaceable&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We may not &lt;em&gt;be&lt;/em&gt; smart, but be can code smarter.&lt;/p&gt;
&lt;div class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;strong&gt;Complex&lt;/strong&gt; 1645–55; 1905–10 for def 7; (adj.) &amp;lt; Latin complexus, past participle of complectī, complectere to embrace, encompass, include, equivalent to complect- (see complect) + -tus past participle suffix; (noun) &amp;lt; Late Latin complexus totality, complex (Latin: inclusion, grasping, embrace), equivalent to complect(ere) + -tus suffix of v. action; reanalysis of the Latin v. as “to intertwine (completely)” has influenced sense of the adj.&lt;a href="#fnref:1" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;strong&gt;Complicated&lt;/strong&gt; 1615–25; &amp;lt; Latin complicātus (past participle of complicāre to fold together), equivalent to com- com- + -plic- (combining form of *plecāre to fold, akin to plectī to plait; see complex) + -ātus -ate1&lt;a href="#fnref:2" class="footnote-back-ref"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
      <pubDate>Sun, 13 Oct 2019 11:15:00 -0600</pubDate>
      <link>https://www.softwaremeadows.com/posts/most_of_us_developers_arent_smart</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/most_of_us_developers_arent_smart</guid>
    </item>
    <item>
      <title>Confirmed Android text punctuation voice commands</title>
      <description>&lt;p&gt;This is what I've confirmed can be done on an Android phone. (From what I've read, Apple is superior in its speech-recognition of punctuation.)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Result&lt;/th&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Enter once then capitalize&lt;/td&gt;
&lt;td&gt;&amp;quot;new line&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enter twice then capitlize&lt;/td&gt;
&lt;td&gt;&amp;quot;new paragraph&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;&amp;quot;period&amp;quot; &amp;quot;dot&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;&amp;quot;question mark&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;&amp;quot;exclamation point&amp;quot; &amp;quot;exclamation mark&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;td&gt;&amp;quot;comma&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;&amp;quot;hyphen&amp;quot; &amp;quot;dash&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;&amp;quot;percent sign&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:-)&lt;/td&gt;
&lt;td&gt;&amp;quot;smiley face&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:-(&lt;/td&gt;
&lt;td&gt;&amp;quot;sad face&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;&amp;quot;dot dot dot&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      <pubDate>Sun, 6 Oct 2019 15:17:00 -0600</pubDate>
      <link>https://www.softwaremeadows.com/posts/confirmed_android_text_punctuation_voice_commands</link>
      <guid isPermaLink="true">https://www.softwaremeadows.com/posts/confirmed_android_text_punctuation_voice_commands</guid>
    </item>
  </channel>
</rss>