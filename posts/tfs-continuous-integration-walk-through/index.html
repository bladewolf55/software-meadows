<!DOCTYPE html>
<html>
  <head>
    <title>TFS Continuous Integration Walk Through Part 5c - Multiple Solutions: Dependencies</title>
    <link rel="stylesheet" type="text/css" href="/css/default.css">
  </head>
  <body>
    <header>Goat Blog</header>
    <nav>
      <ul>
        <li><a href="/">Home</a></li>
        <li class="dropdown">
          <a href="/about">About</a>
          <div class="dropdown-content">
            <a href="/about/contact">Contact Us</a>
            <a href="/about-team">Our Team</a>
          </div>
        </li>
      </ul>
    </nav>
   	<aside id="sidebar">
	   <div id="recent">
       <p><strong>History</strong></p>
       <ol class='tree'><li class='history-year'><label for='2017'>2017</label><input type='checkbox'  id='2017' /><ol><li class='history-month'><label for='2017-8'>August</label><input type='checkbox'  id='2017-8' /><ol><li class='post'><a class='post' href='/posts/dont-use-data-prefix-in-angularjs'>Don't use "data" prefix in AngularJS</a></li></ol></li><li class='history-month'><label for='2017-7'>July</label><input type='checkbox'  id='2017-7' /><ol><li class='post'><a class='post' href='/posts/angularjs-service-with-var-declarations'>AngularJS service with var declarations instead of this. assignments</a></li></ol></li><li class='history-month'><label for='2017-6'>June</label><input type='checkbox'  id='2017-6' /><ol><li class='post'><a class='post' href='/posts/factory-resetting-android-without'>Factory Resetting Android Without Losing Your Life (Metaphorically)</a></li></ol></li><li class='history-month'><label for='2017-5'>May</label><input type='checkbox'  id='2017-5' /><ol><li class='post'><a class='post' href='/posts/identityserver3-with-pkce-part-4'>IdentityServer3 with PKCE Part 4 - Persisting User Data</a></li><li class='post'><a class='post' href='/posts/identityserver3-with-pkce-part-3'>IdentityServer3 with PKCE Part 3 - Persist IdentityServer Configuration</a></li><li class='post'><a class='post' href='/posts/identityserver3-with-pkce-part-2'>IdentityServer3 with PKCE Part 2 - Protected Resource Server</a></li><li class='post'><a class='post' href='/posts/identityserver3-with-pkce-part-1-simple'>IdentityServer3 with PKCE Part 1 - Simple OAuth2 Server</a></li></ol></li><li class='history-month'><label for='2017-3'>March</label><input type='checkbox'  id='2017-3' /><ol><li class='post'><a class='post' href='/posts/tfs-continuous-integration-walk-through'>TFS Continuous Integration Walk Through Part 5c - Multiple Solutions: Dependencies</a></li><li class='post'><a class='post' href='/posts/sane-database-schema-conventions'>Sane Database Schema Conventions</a></li></ol></li></ol></li></ol>
      </div>
	    <div id="tags"></div>
	  </aside>
    <section id="content"><div class='post-title'>
                <a href='https://bladewolf55.gitlab.io/posts/tfs-continuous-integration-walk-through'><h1>TFS Continuous Integration Walk Through Part 5c - Multiple Solutions: Dependencies</h1></a>
                <p class='post-info'>2017-03-28 09:31</p>
            </div><p><a href="images/ci-logo_thumb.png"><img src="images/ci-logo_thumb.png" title="ci-logo" alt="ci-logo" width="126" height="126" /></a> This is part of a series of walk throughs exploring CI in TFS, starting from the ground up. The entire series and source code are maintained at this BitBucket repository.</p>
<p><a href="https://bitbucket.org/bladewolf55/tfs-ci-samples" class="uri">https://bitbucket.org/bladewolf55/tfs-ci-samples</a></p>
<p>Previous Part: <a href="https://bitbucket.org/bladewolf55/tfs-ci-samples/src/default/CI%20Walk%20Through/TFS%20Continuous%20Integration%20Walk%20Through%20Part%205a%20-%20Multiple%20Solutions%20-%20Simple%20Project%20References.md">TFS Continuous Integration Walk Through Part 5b - Multiple Solutions: Simple Project References</a></p>
<h1 id="what-im-talking-about">What I'm Talking About</h1>
<p>Businesses often have source code that's years or decades old, and accumulate problems due to how that code was structured into folders. Especially difficult is how dependencies were managed. It's common to see:</p>
<ul>
<li>Projects with project references to other projects in other solutions, sometimes nesting/cascading in a tangled mess.</li>
<li>Third party libraries that require installation, such as UI controls.</li>
<li>Multiple ways of managing .dll dependencies.</li>
</ul>
<p>Some common challenges--and reasons why the above happen--are:</p>
<ul>
<li>Multiple projects depend on a shared project, and they often need to step through the shared project's code.</li>
<li>Over the years, different developers did things how they liked.</li>
<li>Source control wasn't used, or changed.</li>
</ul>
<h1 id="where-ill-end-up">Where I'll End Up</h1>
<p>I'll start with a set of solutions that have some dependency problems. I'll show how they can work with continuous integration. Then, I'll improve the dependency handling.</p>
<h1 id="a-problematic-structure">A Problematic Structure</h1>
<p>Let's imagine a TFS repository. Instead of a separate Team Project for each solution, there's a single Team Project named $Main that has all the solutions underneath it.</p>
<p>In this folder structure, I'm showing solution folders with their project folders below. So, ReverseIt is a solution folder with the ReverseIt project folder below it, which is the default Visual Studio layout.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">$/Main
_Shared
   NameDb
     NameDb
ReverseIt
  ReverseIt
    &gt; Depends on <span class="fu">RevEngine</span> (project reference)
  RevEngine
    &gt; Depends on jamma.<span class="fu">dll</span>
ReverseNames
  ReverseNames
    &gt; Depends on <span class="fu">RevEngine</span> (project reference)
    &gt; Depends on <span class="fu">NameDb</span> (NuGet package)</code></pre></div>
<ul>
<li>NameDb DLL returns a list of names, is packaged using NuGet, and stored in a local source.</li>
<li>ReverseIt Console reverses whatever text you type in.</li>
<li>RevEngine DLL has ReverseText method. It is a project reference.</li>
<li>Jamma.dll is a third party security dll. The company is out of business.</li>
<li>ReverseNames Console displays a list of reversed names coming from NameDb.</li>
</ul>
<p>What are the pros and cons of this approach?</p>
<p><strong>Pros</strong></p>
<ul>
<li>If you Get Latest on $Main, all the solutions are in their correct relative folders.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>You often have to get source you don't need.</li>
<li>The dependency on relative paths is brittle.</li>
<li>You can't use TFS's project management tools effectively.</li>
<li>Doesn't scale. What if you had fifty solutions using this approach?</li>
</ul>
<h1 id="creating-ci-builds-as-is">Creating CI Builds As Is</h1>
<p>My manager says, &quot;We need to get these projects into TFS Build.&quot;</p>
<p>I ask, &quot;Can I restructure TFS?&quot;</p>
<p>He says, &quot;Not yet.&quot;</p>
<p>I say, &quot;OK.&quot;</p>
<p>Since I'm pretty sure there are dependency problems, the first thing I decide to do is spin up a clean machine, install Visual Studio with no changes, Get Latest on $Main, and try to build all the solutions.</p>
<p>What's this!? Multiple failures? Oh, no! What went wrong?</p>
<ol>
<li>ReverseNames failed because we're depending on an in-house NuGet package source, and didn't configure that, so the NameDb dependency didn't exist.</li>
<li>RevEngine failed because Barry's the only developer who has ever worked on RevEngine, and only his machine has jamma.dll. It was never checked into source control.</li>
</ol>
<p>Quite a bit more could go wrong, but you get the idea. Let's fix these with an eye toward our eventual build server.</p>
<hr />
<p><strong>BONUS CODE!</strong></p>
<p>If I had lots of solutions, I could build all of of them using two files in the root of the folder than has all the solution folders.</p>
<p><strong>BuildAllSolutions.targets</strong></p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;Project</span><span class="ot"> ToolsVersion=</span><span class="st">&quot;14.0&quot;</span>
<span class="ot">         xmlns=</span><span class="st">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>
<span class="ot">         DefaultTargets=</span><span class="st">&quot;Default&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- http://stackoverflow.com/a/9609086/1628707 --&gt;</span>
  <span class="kw">&lt;ItemGroup&gt;</span>
    <span class="kw">&lt;AllFiles</span><span class="ot"> Include=</span><span class="st">&quot;.\**\*.sln&quot;</span><span class="kw">/&gt;</span>
  <span class="kw">&lt;/ItemGroup&gt;</span>
  <span class="kw">&lt;Target</span><span class="ot"> Name=</span><span class="st">&quot;Default&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;PropertyGroup&gt;</span>
    <span class="kw">&lt;BuildCmd&gt;</span>@(AllFiles-&gt;&#39;<span class="dv">&amp;quot;</span>$(MSBuildToolsPath)\msbuild.exe<span class="dv">&amp;quot;</span> <span class="dv">&amp;quot;</span>%(Identity)<span class="dv">&amp;quot;</span> /v:q /fl /flp:errorsonly;logfile=build-logs\%(filename)-log.txt&#39;,&#39;%0D%0A&#39;)<span class="kw">&lt;/BuildCmd&gt;</span>
    <span class="kw">&lt;/PropertyGroup&gt;</span>
    <span class="kw">&lt;Exec</span><span class="ot"> Command=</span><span class="st">&quot;mkdir build-logs&quot;</span><span class="ot"> Condition=</span><span class="st">&quot;!Exists(&#39;build-logs&#39;)&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;Exec</span><span class="ot"> Command=</span><span class="st">&quot;$(BuildCmd)&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/Target&gt;</span>
<span class="kw">&lt;/Project&gt;</span></code></pre></div>
<p><strong>BuildAllSolutions.cmd</strong></p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">--rem path to your latest VS build version
<span class="st">&quot;C:\Program Files (x86)\MSBuild\14.0</span><span class="sc">\B</span><span class="st">in\msbuild.exe&quot;</span> BuildAllSolutions.<span class="fu">targets</span>
pause</code></pre></div>
<p>Running the cmd file creates a folder named &quot;build-logs&quot;, recursively builds each solution, and outputs each solution's errors. If a solution's log file is not empty, there was a build problem.</p>
<p><strong>END BONUS CODE</strong></p>
<hr />
<h2 id="dealing-with-a-local-nuget-package-source">Dealing With a Local NuGet Package Source</h2>
<p>There are four (technically five or six!) places to store NuGet config files containing package source information, and two ways to configure package source in TFS Build.</p>
<h3 id="nuget-config-file-locations">NuGet Config File Locations</h3>
<p>Let's assume our in-house NuGet source is located at <a href="http://ngserver/nuget" class="uri">http://ngserver/nuget</a>.</p>
<ol>
<li><strong>User Profile</strong> - Enter it into Visual Studio's settings. This is fine for regular development, but not good for a build server because the build agent service will run as either Local System or a specific user account such as &quot;tfsagent&quot;.</li>
</ol>
<p><a href="images/2017-03-17_155817_thumb.png"><img src="images/2017-03-17_155817_thumb.png" title="2017-03-17_155817" alt="2017-03-17_155817" width="758" height="448" /></a></p>
<p>You can also manually edit the user profile's nuget.config, which is what the Visual Studio setting dialog is doing. The file is located at %APPDATA%\NuGet\NuGet.config. You add the source under packageSources.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;utf-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;configuration&gt;</span>
  <span class="kw">&lt;activePackageSource&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;nuget.org&quot;</span><span class="ot"> value=</span><span class="st">&quot;https://www.nuget.org/api/v2/&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/activePackageSource&gt;</span>
  <span class="kw">&lt;packageSources&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;nuget.org&quot;</span><span class="ot"> value=</span><span class="st">&quot;https://api.nuget.org/v3/index.json&quot;</span><span class="ot"> protocolVersion=</span><span class="st">&quot;3&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;NuGet Local Source&quot;</span><span class="ot"> value=</span><span class="st">&quot;http://ngserver/nuget&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/packageSources&gt;</span>
  <span class="kw">&lt;packageRestore&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;enabled&quot;</span><span class="ot"> value=</span><span class="st">&quot;True&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;automatic&quot;</span><span class="ot"> value=</span><span class="st">&quot;True&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/packageRestore&gt;</span>
  <span class="kw">&lt;bindingRedirects&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;skip&quot;</span><span class="ot"> value=</span><span class="st">&quot;False&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/bindingRedirects&gt;</span>
<span class="kw">&lt;/configuration&gt;</span></code></pre></div>
<ol>
<li><strong>Solution</strong> - Create a solution-level nuget.config file.</li>
</ol>
<p>You can create a file named nuget.config, put it in your solution's root and add it to source control. This will determine which NuGet sources the solution uses.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;utf-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;configuration&gt;</span>
  <span class="kw">&lt;packageRestore&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;enabled&quot;</span><span class="ot"> value=</span><span class="st">&quot;True&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;automatic&quot;</span><span class="ot"> value=</span><span class="st">&quot;True&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/packageRestore&gt;</span>
  <span class="kw">&lt;packageSources&gt;</span>
    <span class="co">&lt;!-- uncomment clear if you want to ONLY use these sources --&gt;</span>
    <span class="co">&lt;!-- otherwise, these sources are added to your list --&gt;</span>
    <span class="co">&lt;!-- clear /&gt; --&gt;</span>
  <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;NuGet Local Source&quot;</span><span class="ot"> value=</span><span class="st">&quot;http://ngserver/nuget&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/packageSources&gt;</span>
<span class="kw">&lt;/configuration&gt;</span></code></pre></div>
<p><strong>Note: NuGet 3.3 and earlier looked for a config file in a solution's .nuget folder. Not recommended.</strong></p>
<ol>
<li><strong>Machine-Wide</strong> - Create a machine-wide config file.</li>
</ol>
<p>The machine-wide story is confusing. A machine-wide NuGet config file can reside in one of two folders. The folder changed with the introduction of NuGet 4.0, which is used by Visual Studio 2017.</p>
<ul>
<li><code>%ProgramData%\NuGet\Config\</code> (NuGet 3.x or earlier), or</li>
<li><code>%ProgramFiles(x86)%\NuGet\Config\</code> (NuGet 4.0+)</li>
</ul>
<p>It can be named anything that ends with .config, including <code>NuGet.config</code>. However, a custom name seems recommended.</p>
<p>For example, I could name the file <code>SoftwareMeadows.Online.config</code>. It would contain the package source like this:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;utf-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;configuration&gt;</span>
  <span class="kw">&lt;packageSources&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;NuGet Local Source&quot;</span><span class="ot"> value=</span><span class="st">&quot;http://ngserver/nuget&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/packageSources&gt;</span>
<span class="kw">&lt;/configuration&gt;</span></code></pre></div>
<p>Network Administrators will like this option because they can use it with Group Policies. A policy could target computers in Developers and Build Servers groups and always create the desired config file.</p>
<p><strong>Note: NuGet 4.x does not look for config files in ProgramData.</strong></p>
<ol>
<li><strong>Default Config</strong></li>
</ol>
<p>If you're using NuGet 2.7 through 3.x, default sources can also be configured in the file <code>%ProgramData%\NuGet\NuGetDefaults.config</code>. These show up in Visual Studio as local, not machine-wide, sources.</p>
<p><strong>Note: This file and location will not work with NuGet 4.x</strong></p>
<ol>
<li><strong>Other?</strong></li>
</ol>
<p>You could also put a nuget.config file in any folder and specify it using the nuget.exe -configFile switch, e.g. <code>nuget restore -configfile c:\my.config</code>.</p>
<p><strong>Notes</strong></p>
<ul>
<li>Testing shows that in some cases if the package source URL is the same, only one source key is used. For example, if NuGet.config and NuGetDefaults.config have an identical source URL, the key from NuGet.config is used.</li>
<li>It appears a source listed in NuGetDefaults.config cannot be removed using the <code>&lt;clear /&gt;</code> tag. It can only be disabled.</li>
</ul>
<h3 id="specifying-the-config-in-tfs-build">Specifying the Config in TFS Build</h3>
<p>Whichever method you use below, ensure the agent service has permissions to the config file. The service name will be something like &quot;VSO Agent ([AgentName])&quot;. Microsoft recommends creating a user named &quot;tfsagent&quot;. The default is Local Service.</p>
<p><a href="images/2017-03-17_162121_thumb.png"><img src="images/2017-03-17_162121_thumb.png" title="2017-03-17_162121" alt="2017-03-17_162121" width="420" height="482" /></a></p>
<ol>
<li>TFS Machine-Wide Path - RECOMMENDED</li>
</ol>
<p>Personally, for internal development, I'd add the package source to the build server's machine-wide config file and be done with it. So, my path--assuming VS 2015 installed--would be something like: <code>%ProgramData%\NuGet\Config\SoftwareMeadows.Online.config</code></p>
<p><a href="images/2017-03-17_162400_thumb_25255B1_25255D.png"><img src="images/2017-03-17_162400_thumb_25255B1_25255D.png" title="2017-03-17_162400" alt="2017-03-17_162400" width="565" height="293" /></a></p>
<p>Remember from above this will change if you install Visual Studio 2017 on the build server (or use NuGet 4.x).</p>
<ol>
<li>Add nuget.config to the build agent's profile.</li>
</ol>
<p>Your build server is basically a development machine, with an agent automatically building the software. If you run the service using tfsagent, you could create/edit a nuget.config file found at <code>C:\Users\tfsagent\AppData\Roaming\NuGet</code>.</p>
<ol>
<li>TFS NuGet Installer Path Field</li>
</ol>
<p>If you check in a nuget.config file with the solution, enter the path in your build definition's NuGet Installer step. This path is relative to the Path to Solution. I would use this solution if my team didn't all work in the same network, and so needed to use an authenticated NuGet server such as <a href="http://myget.org/">MyGet</a>.</p>
<p><a href="images/2017-03-17_162452_thumb.png"><img src="images/2017-03-17_162452_thumb.png" title="2017-03-17_162452" alt="2017-03-17_162452" width="507" height="111" /></a></p>
<ol>
<li>Use the -configFile switch</li>
</ol>
<p>You could also put a nuget.config file somewhere on the build server (or network?), and use the -configFile switch. Remember the build agent service needs permission to read the file.</p>
<p><a href="images/2017-03-17_162410_thumb.png"><img src="images/2017-03-17_162410_thumb.png" title="2017-03-17_162410" alt="2017-03-17_162410" width="497" height="166" /></a></p>
<h2 id="dealing-with-barry">Dealing with Barry</h2>
<p>Barry's been with us for five years. Barry drinks his coffee black, and lots of it. Barry knows where every file on his machine is, and would prefer you didn't look over his shoulder. Barry has his code, please leave it alone.</p>
<p>Unfortunately, Barry assumes he'll always be here, and hasn't ever tested what would happen if his machine imploded in a fiery death. I go to Barry and say, &quot;Your code doesn't build on a clean checkout.&quot; Barry storms over to my computer and starts typing. I observe, take notes, and when I see him copying jamma.dll, ask, &quot;What's that?&quot;</p>
<p>&quot;Oh,&quot; he mumbles, &quot;license dll. Forgot about that. Kinda important. RevEngine won't run without it.&quot;</p>
<p>I don't say anything, but make a note that, once I have all the software building and deployable, Barry might not be long for our company. In the meantime, there are two ways I can handle this old dependency.</p>
<ol>
<li>Ensure it's in a folder under the solution or project, reference it there, and add it to source control.</li>
</ol>
<p><a href="images/2017-03-17_164300_thumb_25255B1_25255D.png"><img src="images/2017-03-17_164300_thumb_25255B1_25255D.png" title="2017-03-17_164300" alt="2017-03-17_164300" width="722" height="481" /></a></p>
<ol>
<li>Create the dll as a NuGet package, and add it to my NuGet server.</li>
</ol>
<p><a href="https://dist.nuget.org/index.html">Download nuget.exe</a> and put in same folder as the dll (or put in its own folder and add to the system path variables).</p>
<p>Open a command prompt, change directories to where the dll is, and run <code>nuget spec jamma.dll</code>.</p>
<p>Edit the resulting damma.dll.nuspec file, change or remove elements as desired.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;package</span> <span class="kw">&gt;</span>
  <span class="kw">&lt;metadata&gt;</span>
    <span class="kw">&lt;id&gt;</span>jamma.dll<span class="kw">&lt;/id&gt;</span>
    <span class="kw">&lt;version&gt;</span>3.2.52<span class="kw">&lt;/version&gt;</span>
    <span class="kw">&lt;authors&gt;</span>Jamma Ltd<span class="kw">&lt;/authors&gt;</span>
    <span class="kw">&lt;owners&gt;</span>Jamma Ltd<span class="kw">&lt;/owners&gt;</span>
    <span class="kw">&lt;requireLicenseAcceptance&gt;</span>false<span class="kw">&lt;/requireLicenseAcceptance&gt;</span>
    <span class="kw">&lt;description&gt;</span>License file<span class="kw">&lt;/description&gt;</span>
    <span class="kw">&lt;copyright&gt;</span>Copyright 2017<span class="kw">&lt;/copyright&gt;</span>
  <span class="kw">&lt;/metadata&gt;</span>
<span class="kw">&lt;/package&gt;</span></code></pre></div>
<p><strong>Important: Now move the dll into a subfolder named &quot;lib&quot;</strong></p>
<p>Package the dll using <code>nuget pack</code>.</p>
<p>Add the package (jamma.dll and jamma.dll.nuspect) to your NuGet server however is appropriate, might just be copy/paste, or using nuget push commands. See the NuGet documentation.</p>
<p>Remove the reference from the project, and re-add from NuGet. Build and test. If everything's OK, delete the old jamma.dll file and folder.</p>
<p>Which would I do? Number 2, so that all my external dependencies are handled the same way (NuGet).</p>
<h2 id="its-building-so-add-to-ci">It's Building, so Add to CI</h2>
<p>I test again by deleting and re-getting all the source code, open each and restore any NuGet packages, and build all the solutions. Everything builds, so I'm ready to configure TFS Build for continuous integration.</p>
<p>All my solutions are under the same team project. I'll need to be careful when I create my build definitions that I'm only checking out and building the solutions I want. The key to that is not saving the definition until its Repository and Triggers have been configured.</p>
<p>I'll create the first definition in detail, then just list settings for the remainders.</p>
<p><strong>But first, the NuGet Package Source</strong></p>
<p>If I haven't done it already, I'll add a machine-wide nuget configuration file that has my custom package source.</p>
<p>Create the file <code>%ProgramData%\NuGet\Config\MySource.config</code> with the source definition. In my case, I'm testing with a local NuGet server.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;utf-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;configuration&gt;</span>
  <span class="kw">&lt;packageSources&gt;</span>
    <span class="kw">&lt;add</span><span class="ot"> key=</span><span class="st">&quot;NuGet Test Server&quot;</span><span class="ot"> value=</span><span class="st">&quot;http://localhost:7275/&quot;</span> <span class="kw">/&gt;</span>
  <span class="kw">&lt;/packageSources&gt;</span>
<span class="kw">&lt;/configuration&gt;</span></code></pre></div>
<p><strong>NameDb</strong></p>
<p>Let's start at the top with the simple one, NameDb. In TFS, navigate to the correct collection and the Main team project. Then open the Build tab, start a new build and choose the Visual Studio template.</p>
<p><a href="images/2017-03-25_143134_thumb_25255B1_25255D.png"><img src="images/2017-03-25_143134_thumb_25255B1_25255D.png" title="2017-03-25_143134" alt="2017-03-25_143134" width="742" height="330" /></a></p>
<p>Create using the repository source Main Team Project.</p>
<p><a href="images/2017-03-25_143854_thumb.png"><img src="images/2017-03-25_143854_thumb.png" title="2017-03-25_143854" alt="2017-03-25_143854" width="617" height="618" /></a></p>
<p>Delete the Index, Copy and Publish steps. I can add those back if we want them. I don't need the NuGet installer step, either, but I'll configure it as an example since the other projects need it.</p>
<p><a href="images/2017-03-25_144248_thumb.png"><img src="images/2017-03-25_144248_thumb.png" title="2017-03-25_144248" alt="2017-03-25_144248" width="567" height="366" /></a></p>
<p>Set the NuGet Installer path to the NameDb solution file.</p>
<p><a href="images/2017-03-25_145021_thumb_25255B1_25255D.png"><img src="images/2017-03-25_145021_thumb_25255B1_25255D.png" title="2017-03-25_145021" alt="2017-03-25_145021" width="736" height="256" /></a></p>
<p>Set the Visual Studio Build path to the NameDb solution file.</p>
<p><a href="images/2017-03-25_145758_thumb_25255B1_25255D.png"><img src="images/2017-03-25_145758_thumb_25255B1_25255D.png" title="2017-03-25_145758" alt="2017-03-25_145758" width="739" height="263" /></a></p>
<p>Set the Visual Studio Test &quot;Test Assembly&quot; to the solution folder path. This is the physical folder where the agent will have pulled the files from TFS, the same as the LocalPath path we'll choose in Repository. The path definition means &quot;Run any dll with &quot;test&quot; in its name under the build definition name, but not in the obj folders.&quot; Since our build definition will be Release, it'll run Release/NameDb.Tests.dll.</p>
<p><a href="images/2017-03-25_150526_thumb_25255B1_25255D.png"><img src="images/2017-03-25_150526_thumb_25255B1_25255D.png" title="2017-03-25_150526" alt="2017-03-25_150526" width="747" height="276" /></a></p>
<p>Do NOT Save!</p>
<p>Change to the Repository tab. This controls what source code gets checked out by the build. Change the mapped paths. We'll keep the cloaked Drops folder, even though we aren't publishing anything yet.</p>
<p>Notice the LocalPath is set. This is so the contents of the NameDb solution folder are placed under a _Shared\NameDb folder, just like in the repository. It's not strictly needed for this build, but remember how this works if you're building multiple solutions with project dependencies in relative folders.</p>
<p><a href="images/2017-03-25_151640_thumb.png"><img src="images/2017-03-25_151640_thumb.png" title="2017-03-25_151640" alt="2017-03-25_151640" width="731" height="392" /></a></p>
<p>Change to the Variables tab and ensure the BuildConfiguration is &quot;release&quot;.</p>
<p><a href="images/2017-03-25_152836_thumb_25255B1_25255D.png"><img src="images/2017-03-25_152836_thumb_25255B1_25255D.png" title="2017-03-25_152836" alt="2017-03-25_152836" width="736" height="344" /></a></p>
<p>Change to the Triggers tab. This controls what starts a build. Check Continuous Integration and set the path to the NameDb folder. We only want to build if a file in NameDb changes.</p>
<p><a href="images/2017-03-25_153129_thumb.png"><img src="images/2017-03-25_153129_thumb.png" title="2017-03-25_153129" alt="2017-03-25_153129" width="546" height="314" /></a></p>
<p>Now Save the definition and give it a good name like &quot;DbName&quot;.</p>
<p><a href="images/2017-03-25_153325_thumb.png"><img src="images/2017-03-25_153325_thumb.png" title="2017-03-25_153325" alt="2017-03-25_153325" width="515" height="235" /></a></p>
<p>Finally, queue the build and see if it succeeds!</p>
<blockquote>
<p><strong>Important</strong><br />
Check each step's output for what you expect. Especially, check that tests ran! The test step will success even if it doesn't find tests!</p>
</blockquote>
<p><a href="images/2017-03-25_153438_thumb.png"><img src="images/2017-03-25_153438_thumb.png" title="2017-03-25_153438" alt="2017-03-25_153438" width="340" height="138" /></a></p>
<p><a href="images/2017-03-25_155144_thumb_25255B1_25255D.png"><img src="images/2017-03-25_155144_thumb_25255B1_25255D.png" title="2017-03-25_155144" alt="2017-03-25_155144" width="742" height="202" /></a></p>
<p>For the next solutions, I'll just list the settings for the build definitions. All of them use the Visual Studio template, and only keep the NuGet, Build and Test steps.</p>
<p><strong>ReverseIt</strong></p>
<p>BUILD TAB</p>
<ul>
<li>NuGet Installer path to solution: <code>$/Main/ReverseIt/ReverseIt.sln</code></li>
<li>Build solution path: <code>$/Main/ReverseIt/ReverseIt.sln</code></li>
<li>Test assembly path: <code>ReverseIt\**\$(BuildConfiguration)\*test*.dll;-:**\obj\**</code></li>
</ul>
<p>REPOSITORY TAB</p>
<ul>
<li>Map Server Path <code>$/Main/ReverseIt</code> to Local Path <code>ReverseIt</code></li>
<li>Map Cloaked Path <code>$/Main/ReverseIt/Drops</code></li>
</ul>
<p>VARIABLES TAB</p>
<ul>
<li>BuildConfiguration: release</li>
</ul>
<p>TRIGGERS TAB</p>
<ul>
<li>Include <code>$/Main/ReverseIt</code></li>
</ul>
<p><strong>ReverseNames</strong></p>
<p>Strictly speaking, I don't need to build RevEngine. Any changes I make will trigger ReverseIt to build, and if it fails then someone--hopefully I--will be notified. What I do need to do is get the source code into the correct relative folder, and install the NuGet packages. In short, I need to ensure RevEngine can be used by ReverseNames.</p>
<p>So, I'm going to have two sets of steps; one for RevEngine, and one for ReverseNames. It's a brittle definition: Whoever, works on RevEngine needs to know about this build, too, in case something needs to change.</p>
<p>BUILD TAB</p>
<ul>
<li><p>NuGet Installer RevEngine</p>
<ul>
<li>Path to solution: <code>ReverseIt\**\*.csproj</code></li>
<li>NuGet Arguments: <code>-PackagesDirectory ..\packages</code></li>
</ul>
<p>Notice I set the path to the <em>local project</em> files. This will restore packages for any .csproj file found. I also explicitly say where to put the packages folder relative to the .csproj file.</p></li>
<li><p>NuGet Installer ReverseNames</p>
<ul>
<li>Path to solution: $/Main/ReverseNames/ReverseNames.sln</li>
</ul></li>
<li><p>Build ReverseNames</p>
<ul>
<li>Solution path: $/Main/ReverseNames/ReverseNames.sln</li>
</ul></li>
<li><p>Test ReverseNames</p>
<ul>
<li>Assembly path: <code>ReverseNames\**\$(BuildConfiguration)\*test*.dll;-:**\obj\**</code></li>
</ul></li>
</ul>
<p>REPOSITORY TAB<br />
This is critical. I'm telling the build <em>exactly</em> which project folders to pull from ReverseIt, i.e. RevEngine and RevEngine.Tests. This way I don't pull and build ReverseIt.csproj.</p>
<p>If I add a test project later, I'll need to add its mapped path here. Note that I removed the Drops cloaked path since I don't need it.</p>
<ul>
<li>Map Server Path <code>$/Main/ReverseIt/RevEngine</code> to Local Path <code>ReverseIt\RevEngine</code></li>
<li>Map Server Path <code>$/Main/ReverseIt/RevEngine.Tests</code> to Local Path <code>ReverseIt\RevEngine.Tests</code></li>
<li>Map Server Path <code>$/Main/ReverseNames</code> to Local Path <code>ReverseNames</code></li>
</ul>
<p>VARIABLES TAB</p>
<ul>
<li>BuildConfiguration: release</li>
</ul>
<p>TRIGGERS TAB<br />
I'm triggering the build if ReverseNames changes.</p>
<ul>
<li>Include <code>$/Main/ReverseNames</code></li>
</ul>
<p>Here are some screenshots of the ReverseNames definition.</p>
<p><a href="images/2017-03-26_190426_thumb.png"><img src="images/2017-03-26_190426_thumb.png" title="2017-03-26_190426" alt="2017-03-26_190426" width="520" height="366" /></a></p>
<p><a href="images/2017-03-26_190546_thumb.png"><img src="images/2017-03-26_190546_thumb.png" title="2017-03-26_190546" alt="2017-03-26_190546" width="758" height="371" /></a></p>
<p><a href="images/2017-03-26_190620_thumb.png"><img src="images/2017-03-26_190620_thumb.png" title="2017-03-26_190620" alt="2017-03-26_190620" width="527" height="278" /></a></p>
<h1 id="improving-the-solutions-dependencies-and-team-projects">Improving the Solutions, Dependencies and Team Projects</h1>
<p>What I've done so far works. Sort of. But it's not exactly ideal, especially if there were fifty solutions, not just three. One big thing I lose is the ability to maintain separate project boards and work items per project. To do that, I'd really like a separate Team Project per solution (or in some cases it could be multiple solutions).</p>
<p>The team projects might look like this.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">$\NameDb
$\RevEngine
$\ReverseIt
$\ReverseNames</code></pre></div>
<p>And then there's the project reference. The project reference is bound to cause headaches in the future. One developer will change RevEngine and silently break the ReverseNames build. I say &quot;silently,&quot; because it could be something like adding a new unit test project that doesn't get run by ReverseNames because it doesn't get pulled from source control.</p>
<p>Because it's a shared dependency, RevEngine needs to be in its own solution under _Shared and published as a NuGet package.</p>
<p>Right about now, someone's saying, &quot;But but but! I need to be able to step through that code! And make changes that I can test against ReverseIt!!&quot;</p>
<p>This might point to too much coupling between the projects, but so what? That's what you need. For debugging,</p>
<ul>
<li>Publish the NuGet <a href="https://docs.microsoft.com/en-us/nuget/create-packages/symbol-packages">package with debug symbols</a>. This solves the debugging problem.</li>
</ul>
<p>If you really need to change code in the context of the solution,</p>
<ol>
<li>Drop the RevEngine NuGet reference from ReverseNames.</li>
<li>Get the latest RevEngine code into its _Shared\RevEngine folder.</li>
<li>Temporarily add the project reference to ReverseNames.</li>
<li>Do the work.</li>
<li>When finished, drop the RevEngine project reference.</li>
<li>ReAdd the NuGet reference (which doesn't have your changes, sorry).</li>
<li>Open the RevEngine solution and run the tests.</li>
<li>Commit the RevEngine changes, which, sorry, need to be taken through QA, published, etc.</li>
<li>When that's finished, update the RevEngine NuGet package in ReverseNames.</li>
<li>Run the tests, commit, QA, etc.</li>
</ol>
<p>In other words, you need to treat RevEngine as if it were some third party assembly like Entity Framework or NLog.</p>
<p>All of this leads to...</p>
<h1 id="key-thinking-to-managing-dependencies">Key Thinking to Managing Dependencies</h1>
<ol>
<li>Treat your dependencies as if they're third party.</li>
<li>Shared dependencies need to be in their own solutions.</li>
<li>What does it take to check out, build and test the solution on a new computer?</li>
<li>How would you store the project(s) on GitHub or other public remote repository?</li>
</ol>
<h1 id="the-plan">The Plan</h1>
<p>I'm going to do just three things, but they'll make a big difference.</p>
<ol>
<li>Reorganize the solutions into discrete team projects</li>
<li>Publish shared project references as NuGet packages</li>
<li>Update projects to use the packages</li>
</ol>
<blockquote>
<p><strong>Important</strong><br />
Before getting started in a production environment, I'd disable all of the affected TFS Build definitions. I don't want anything running if I don't need to.</p>
<p>I would also make a backup copy of all the affected source code, just in case something gets lost.</p>
</blockquote>
<h1 id="reorganizing-into-team-projects">Reorganizing into Team Projects</h1>
<p>First, I'll create my new team projects. Then I'll move my code.</p>
<blockquote>
<p><strong>Note</strong><br />
You can also add team projects using the Visual Studio Team Explorer.</p>
</blockquote>
<ol>
<li><p>Open TFS in the browser, e.g. <a href="http://nesbit:8080/tfs" class="uri">http://nesbit:8080/tfs</a>. Or, if you know your collection's name, you can open it directly and skip to step 4. (e.g. <a href="http://nesbit:8080/tfs/CICollection3/_admin" class="uri">http://nesbit:8080/tfs/CICollection3/_admin</a>)</p></li>
<li><p>Click the upper right hand corner settings &quot;gear&quot; icon to open the Manage Server page.</p>
<p><a href="images/2017-03-27_085328_thumb.png"><img src="images/2017-03-27_085328_thumb.png" title="2017-03-27_085328" alt="2017-03-27_085328" width="267" height="90" /></a></p></li>
<li><p>Select the Collection holding your team projects, and click &quot;View the collection administration page&quot;.</p>
<p><a href="images/2017-03-27_085913_thumb.png"><img src="images/2017-03-27_085913_thumb.png" title="2017-03-27_085913" alt="2017-03-27_085913" width="506" height="400" /></a></p></li>
<li><p>Click New Team Project, enter the information and Create.</p>
<p><a href="images/2017-03-27_090645_thumb_25255B1_25255D.png"><img src="images/2017-03-27_090645_thumb_25255B1_25255D.png" title="2017-03-27_090645" alt="2017-03-27_090645" width="706" height="545" /></a></p></li>
</ol>
<p>Repeat to create the four team projects.</p>
<p><a href="images/2017-03-27_091136_thumb.png"><img src="images/2017-03-27_091136_thumb.png" title="2017-03-27_091136" alt="2017-03-27_091136" width="219" height="288" /></a></p>
<p>We can't move the code using the TFS web application, so</p>
<ol>
<li><p>Open Visual Studio</p></li>
<li><p>Open Team Explorer and click the plug icon to Manage Connections</p>
<p><a href="images/2017-03-27_091617_thumb.png"><img src="images/2017-03-27_091617_thumb.png" title="2017-03-27_091617" alt="2017-03-27_091617" width="433" height="367" /></a></p></li>
<li><p>Double click the collection you're using to connect to it.</p>
<p><a href="images/2017-03-27_091812_thumb.png"><img src="images/2017-03-27_091812_thumb.png" title="2017-03-27_091812" alt="2017-03-27_091812" width="305" height="210" /></a></p></li>
<li><p>Open Source Control Explorer.</p>
<p><a href="images/2017-03-27_091911_thumb.png"><img src="images/2017-03-27_091911_thumb.png" title="2017-03-27_091911" alt="2017-03-27_091911" width="240" height="283" /></a></p></li>
<li><p>The new team project folders need to be mapped to local folders. This is kind of a pain, but with TFS Version Control there's no getting around it. It's easier with git. I would create a new folder named something like TempTeams to hold the new team projects, finish the moves, then delete all my source code mappings and start over. Like I said, a pain. <strong>Be <em>very</em> careful when doing all this that you don't accidentally delete source code from TFS you didn't want to.</strong></p></li>
<li><p>To map a team project folder, select it and click the Not Mapped link. Enter the destination folder, and when prompted Get the latest code (there won't be any, that's OK). Map all the team project folders.</p>
<p><a href="images/2017-03-27_093743_thumb.png"><img src="images/2017-03-27_093743_thumb.png" title="2017-03-27_093743" alt="2017-03-27_093743" width="686" height="329" /></a></p></li>
<li><p>Open the NameDb solution. TFS still doesn't natively allow moving multiple files/folders at once, so we need to move the project contents one a time. First, I'll move the solution file. Right-click, select Move, and enter the NameDb team project. The file will be moved to the NameDb team project.</p>
<p><a href="images/2017-03-27_092818_thumb.png"><img src="images/2017-03-27_092818_thumb.png" title="2017-03-27_092818" alt="2017-03-27_092818" width="384" height="497" /></a></p>
<p><a href="images/2017-03-27_094508_thumb.png"><img src="images/2017-03-27_094508_thumb.png" title="2017-03-27_094508" alt="2017-03-27_094508" width="528" height="234" /></a></p></li>
<li><p>Move the NameDb and NameDb.Tests project folders the same way. You <em>can</em> right-click and move an entire folder, just not multiple folders.</p></li>
<li><p>When finished, Commit the changes.</p></li>
<li><p>You can now delete the NameDb folder from under $/Main/_Shared and commit that change.</p></li>
</ol>
<p>Now I'm going to move just the RevEngine project folders to the new RevEngine team project. Later, I'll create their solution file.</p>
<p>Open the ReverseIt folder. Move the RevEngine and RevEngine.Test folders.</p>
<p><a href="images/2017-03-27_095844_thumb.png"><img src="images/2017-03-27_095844_thumb.png" title="2017-03-27_095844" alt="2017-03-27_095844" width="595" height="163" /></a></p>
<p><a href="images/2017-03-27_100012_thumb.png"><img src="images/2017-03-27_100012_thumb.png" title="2017-03-27_100012" alt="2017-03-27_100012" width="610" height="164" /></a></p>
<p>At this point, I move the remaining ReverseIt files/folders to their new team project. Likewise the ReverseNames solution.</p>
<p>Commit the changes. Delete the folders from $/Main, and commit that change, too.</p>
<p><strong>Do NOT delete the $/Main team project! The TFS Build definitions would be deleted, too.!</strong></p>
<p>Finally, go to the RevEngine project in your local working folder, i.e. <code>..TempTeams\RevEngine\RevEngine</code>, open RevEngine.csproj. This will open the project in a solution, we just haven't saved the solution file yet.</p>
<p>Add the RevEngine.Tests project to the solution.</p>
<p><a href="images/2017-03-27_101947_thumb.png"><img src="images/2017-03-27_101947_thumb.png" title="2017-03-27_101947" alt="2017-03-27_101947" width="269" height="293" /></a></p>
<p>Now I have to be careful. I select the solution in Solution Explorer. Then, File &gt; Save RevEngine.sln As.</p>
<p><a href="images/2017-03-27_102153_thumb.png"><img src="images/2017-03-27_102153_thumb.png" title="2017-03-27_102153" alt="2017-03-27_102153" width="334" height="446" /></a></p>
<p>In the Save As dialog, I navigate <em>up</em> one folder, so my solution file is at the root of RevEngine.</p>
<p><a href="images/2017-03-27_102556_thumb.png"><img src="images/2017-03-27_102556_thumb.png" title="2017-03-27_102556" alt="2017-03-27_102556" width="670" height="473" /></a></p>
<p>Now, I drag and drop the solution file into the Source Control Explorer's RevEngine team project.</p>
<p><a href="images/2017-03-27_102848_thumb_25255B1_25255D.png"><img src="images/2017-03-27_102848_thumb_25255B1_25255D.png" title="2017-03-27_102848" alt="2017-03-27_102848" width="741" height="276" /></a></p>
<p>Commit the change.</p>
<p>My projects are reorganized, and a couple will build (NameDb and RevEngine). Time to turn handle the RevEngine dependency.</p>
<h1 id="publish-shared-project-references-as-nuget-packages">Publish shared project references as NuGet packages</h1>
<p>I'm still working in the TempTeams folder. I'll wait until everything's working before going back to my preferred folders.</p>
<p>Creating NuGet packages can be complex. For this walkthrough, I'm showing the simplest thing that works; I'm sure these steps are not ideal. The following assumes I have a local NuGet server at <a href="http://localhost:7275/nuget" class="uri">http://localhost:7275/nuget</a> that doesn't require an API key for pushing packages (not recommended), and does allow pushing symbols.</p>
<ol>
<li><p>Open the solution, and edit the RevEngine Project Properties &gt; Application &gt; Assembly Information.</p></li>
<li><p>Ensure Title, Description, Company and Product are filled in.</p>
<p><a href="images/2017-03-27_113329_thumb.png"><img src="images/2017-03-27_113329_thumb.png" title="2017-03-27_113329" alt="2017-03-27_113329" width="589" height="450" /></a></p></li>
<li><p>Save <em>and build</em> the solution. You must build, because nuget packs the built dll. It does not build the solution for you.</p></li>
<li><p>Download the latest recommended <a href="https://dist.nuget.org/index.html">NuGet.exe file</a>.</p></li>
<li><p>Put nuget.exe in the RevEngine project folder.</p></li>
<li><p>Open a command prompt and change directory to the RevEngine project folder.</p></li>
<li><p>Run <code>nuget spec</code> to create a RevEngine.nuspec file</p></li>
<li><p>Edit RevEngine.nuspec and make these changes:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;package</span> <span class="kw">&gt;</span>
  <span class="kw">&lt;metadata&gt;</span>
    <span class="kw">&lt;id&gt;</span>$id$<span class="kw">&lt;/id&gt;</span>
    <span class="kw">&lt;version&gt;</span>$version$<span class="kw">&lt;/version&gt;</span>
    <span class="kw">&lt;title&gt;</span>$title$<span class="kw">&lt;/title&gt;</span>
    <span class="kw">&lt;authors&gt;</span>$author$<span class="kw">&lt;/authors&gt;</span>
    <span class="kw">&lt;owners&gt;</span>$author$<span class="kw">&lt;/owners&gt;</span>
    <span class="kw">&lt;description&gt;</span>$description$<span class="kw">&lt;/description&gt;</span>
  <span class="kw">&lt;/metadata&gt;</span>
<span class="kw">&lt;/package&gt;</span></code></pre></div></li>
<li><p>Run <code>nuget pack -Symbols</code> to create the regular and symbols package. Remember that, in our case, we want a symbols package so that we can step through the assembly without using a project reference.</p></li>
<li><p>Run <code>nuget push *.nupkg -Source http://localhost:7275/api/v2/package</code>. This will push both of the packages.</p></li>
</ol>
<h1 id="update-projects-to-use-the-packages">Update projects to use the packages</h1>
<p>This one should be pretty easy. In any solution that has RevEngine as a project reference, remove the project and the reference, then install the NuGet package. Notice that jamma.dll is installed as well, because RevEngine depends on it and the RevEngine project was referencing the jamma.dll NuGet package when it was packages.</p>
<p>After updating, if I open ReverseIt (for example), put a breakpoint on this line,</p>
<p><code>Console.WriteLine(util.ReverseText(text));</code></p>
<p>then run the program, I can step into RevEngine.TextUtilities.cs, which is now part of the debugging symbols.</p>
<h1 id="update-tfs-build-definitions">Update TFS Build Definitions</h1>
<p>It's time to get our builds working again!</p>
<p>TFS doesn't natively support copying/moving build definitions. One solution is to write code using the TFS web API to clone definitions:</p>
<p><a href="http://www.eidias.com/blog/2016/3/7/tfs-2015-cloneimportexport-build-definition-between-team-projects" class="uri">http://www.eidias.com/blog/2016/3/7/tfs-2015-cloneimportexport-build-definition-between-team-projects</a></p>
<p>However, there's a TFS extension for this, which really saves the day. You can download it here.</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=onlyutkarsh.ExportImportBuildDefinition">Export/Import Build Definitions</a></p>
<blockquote>
<p><strong>Note</strong><br />
If using TFS 2015, you must use version <a href="https://github.com/onlyutkarsh/ExportImportBuildDefinition/releases/tag/v0.0.2">v0.0.2</a>. Later versions only work with TFS 2017.</p>
</blockquote>
<p>Follow the instructions to install the extension.</p>
<p>To install 'Export/Import Build Definition' (EIBD) on Team Foundation Server 2015 Update 2 and above, perform the following steps:</p>
<ol>
<li>Navigate to the Team Foundation Server Extensions page on your server. (For example, <a href="http://someserver:8080/tfs/\_gallery/manage" class="uri">http://someserver:8080/tfs/\_gallery/manage</a>)</li>
<li>Click Upload new extension and select the file you have just downloaded.</li>
<li>After the extension has successfully uploaded, click Install and select the Team Project Collection to install into.</li>
</ol>
<p>To move NameDb:</p>
<ol>
<li><p>In the Main team project Build tab, right-click the build definition and choose Export. Save the json file to a folder such as TfsBuildExports.</p>
<p><a href="images/2017-03-27_144558_thumb.png"><img src="images/2017-03-27_144558_thumb.png" title="2017-03-27_144558" alt="2017-03-27_144558" width="198" height="528" /></a></p></li>
<li><p>Change to the NameDb team project Build tab. EIBD has a known limitation: the Export/Import menu items can only be seen on a build definition name, not the &quot;All build definitions&quot; item. So, if necessary, create an empty definition and save it with a non-conflicting name.</p></li>
<li><p>Right-click a definition and choose Import, selecting the .json file.</p></li>
<li><p>Edit the imported definition.</p></li>
<li><p>Make the following changes.</p></li>
</ol>
<p>BUILD</p>
<ul>
<li>NuGet Installer path: $/NameDb/NameDb.sln</li>
<li>Build path: $/NameDb/NameDb.sln</li>
<li>Test path: *<em>$(BuildConfiguration)*test</em>.dll;-:*<em>\obj*</em></li>
</ul>
<p>REPOSITORY</p>
<ul>
<li><p>Map $/NameDb, leave Local Path empty</p>
<p><a href="images/2017-03-27_145831_thumb.png"><img src="images/2017-03-27_145831_thumb.png" title="2017-03-27_145831" alt="2017-03-27_145831" width="686" height="119" /></a></p></li>
</ul>
<p>TRIGGERS</p>
<ul>
<li>Include $/NameDb</li>
</ul>
<ol>
<li>Test!</li>
</ol>
<p><strong>ReverseIt</strong></p>
<p>Use the same approach as NameDb, namely changing the paths in Build, Repository and Triggers. (In fact, ReverseIt would work with the default Visual Studio template.)</p>
<p><strong>ReverseNames</strong></p>
<p>Likewise, ReverseNames can be simplified because I no longer have the RevEngine project to deal with. In fact, all I have to do is delete anything related to RevEngine, then update the remaining paths as I've done above.</p>
<p><strong>RevEngine</strong></p>
<p>This is a new build definition, and it follows the same simplified pattern as above.</p>
<h1 id="what-just-happened">What Just Happened?</h1>
<p>I'll tell you what. Our build definitions got simpler because</p>
<ol>
<li>We converted our project references to NuGet packages.</li>
<li>We contained our code in team projects.</li>
</ol>
<p>Admittedly, the sample was a pretty simple case. I could have a team project that legitimately encompasses multiple solutions. But if I still apply the key principles from above, I can have clean maintenance and simpler builds. As a bonus, it should be much easier to switch to git if I want, since I'm now treating my code as discrete instead of monolithic.</p>
<h1 id="clean-up">Clean Up</h1>
<p>I can now delete the $/Main team project. But, despite there being a right-click menu item, I can't do it from Source Control Explorer. So, (sigh), back to the web interface and my collection administration page. Select Delete from the dropdown to the left of the team project.</p>
<p><a href="images/2017-03-27_101321_thumb.png"><img src="images/2017-03-27_101321_thumb.png" title="2017-03-27_101321" alt="2017-03-27_101321" width="238" height="281" /></a></p>
<p>Am I <em>sure</em> the team project is empty? If so, enter its name and delete it.</p>
<p><a href="images/2017-03-27_101437_thumb.png"><img src="images/2017-03-27_101437_thumb.png" title="2017-03-27_101437" alt="2017-03-27_101437" width="515" height="314" /></a></p>
<h1 id="references">References</h1>
<p><a href="https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package">Creating a Package</a><br />
<a href="https://docs.microsoft.com/en-us/nuget/consume-packages/configuring-nuget-behavior">Configuring NuGet Behavior</a><br />
<a href="http://softwareengineering.stackexchange.com/a/336984">Using Private NuGet Repository</a><br />
<a href="http://stackoverflow.com/a/32624016/1628707">How to Get TFS2015 Build to Restore from Custom NuGet Source 1</a><br />
<a href="http://stackoverflow.com/a/31384347/1628707">How to Get TFS2015 Build to Restore from Custom NuGet Source 2</a><br />
<a href="http://stackoverflow.com/a/28593688/1628707">NuGet Package Source Config Locations</a> <a href="http://blog.nuget.org/20161121/introducing-nuget4.0.html">Introducing NuGet 4</a> <a href="http://stackoverflow.com/a/27569020/1628707">Specifying NuGet Config path for TFS Build</a></p>
<p>Next Part: <a href="https://bitbucket.org/bladewolf55/tfs-ci-samples/src/default/CI%20Walk%20Through/TFS%20Continuous%20Integration%20Walk%20Through%20Part%205a%20-%20Multiple%20Solutions%20-%20Build%20Settings.md">TFS Continuous Integration Walk Through Part 5d - Multiple Solutions: Build Settings</a></p>
</section>
    
    <footer><p>Copyright &copy; Charles L Flatt</p></footer>
  </body>
</html>
