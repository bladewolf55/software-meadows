<!DOCTYPE html>
<html>
  <head>
    <title>Sane Database Schema Conventions</title>
    <link rel="stylesheet" type="text/css" href="http://bladewolf55.gitlab.io/smblog/css/default.css">
  </head>
  <body>
    <header>Questor</header>
    <nav>
      <ul>
        <li><a href="http://bladewolf55.gitlab.io/smblog/">Home</a></li>
        <li class="dropdown">
          <a href="http://bladewolf55.gitlab.io/smblog/about">About</a>
          <div class="dropdown-content">
            <a href="http://bladewolf55.gitlab.io/smblog/about/contact">Contact Us</a>
            <a href="http://bladewolf55.gitlab.io/smblog/about-team">Our Team</a>
          </div>
        </li>
      </ul>
    </nav>
   	<aside id="sidebar">
	   <div id="recent">
       <p><strong>History</strong></p>
       <ol class='tree'><li class='history-year'><label for='2017'>2017</label><input type='checkbox'  id='2017' /><ol><li class='history-month'><label for='2017-8'>August</label><input type='checkbox'  id='2017-8' /><ol><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/dont-use-data-prefix-in-angularjs'>Don't use "data" prefix in AngularJS</a></li></ol></li><li class='history-month'><label for='2017-7'>July</label><input type='checkbox'  id='2017-7' /><ol><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/angularjs-service-with-var-declarations'>AngularJS service with var declarations instead of this. assignments</a></li></ol></li><li class='history-month'><label for='2017-6'>June</label><input type='checkbox'  id='2017-6' /><ol><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/factory-resetting-android-without'>Factory Resetting Android Without Losing Your Life (Metaphorically)</a></li></ol></li><li class='history-month'><label for='2017-5'>May</label><input type='checkbox'  id='2017-5' /><ol><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/identityserver3-with-pkce-part-4'>IdentityServer3 with PKCE Part 4 - Persisting User Data</a></li><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/identityserver3-with-pkce-part-3'>IdentityServer3 with PKCE Part 3 - Persist IdentityServer Configuration</a></li><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/identityserver3-with-pkce-part-2'>IdentityServer3 with PKCE Part 2 - Protected Resource Server</a></li><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/identityserver3-with-pkce-part-1-simple'>IdentityServer3 with PKCE Part 1 - Simple OAuth2 Server</a></li></ol></li><li class='history-month'><label for='2017-3'>March</label><input type='checkbox'  id='2017-3' /><ol><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/tfs-continuous-integration-walk-through'>TFS Continuous Integration Walk Through Part 5c - Multiple Solutions: Dependencies</a></li><li class='post'><a class='post' href='http://bladewolf55.gitlab.io/smblog/posts/sane-database-schema-conventions'>Sane Database Schema Conventions</a></li></ol></li></ol></li></ol>
      </div>
	    <div id="tags"></div>
	  </aside>
    <section id="content"><div class='post-title'>
                <a href='http://bladewolf55.gitlab.io/smblog/posts/sane-database-schema-conventions'><h1>Sane Database Schema Conventions</h1></a>
                <p class='post-info'>2017-03-23 12:11</p>
            </div><h1 id="rationale">Rationale</h1>
<p>These are sane conventions for constructing and naming a database schema. They aren't new, and there's sure to be something someone doesn't like. They are biased toward the .Net EntityFramework, which itself was influenced by the Ruby on Rails ActiveRecord conventions by David Heinemeier Hansson.</p>
<p>Using these conventions makes it easier to translate the tables into classes. While this isn't always desirable (or correct), it often is.</p>
<h1 id="sample">Sample</h1>
<p>This sample schema exemplifies the conventions, and shows most relationships you'll encounter. It's semi-realistic. PropertyRecords is contrived to show a pseudo one-to-one relationship. (Note: MS SQL doesn't allow a <em>true</em> one-to-one structure, as different tables' rows can't be simultaneously created.)</p>
<p>Â </p>
<p><a href="images/sample-schema_thumb.png"><img src="images/sample-schema_thumb.png" title="sample-schema" alt="sample-schema" width="642" height="703" /></a></p>
<ul>
<li>A Customer has an Initial contact Employee, Support Employee and a Salesperson. An Employee can service multiple Customers.</li>
<li>An Employee can be a Salesperson.</li>
<li>A Customer has one or more Addresses, an Address belongs to one Customer.</li>
<li>An Address has one Property Record, a Property Record is for one Address.</li>
<li>A Customer has zero or more Orders, an Order has one Customer.</li>
<li>An Order can have many Vendors, a Vendor can fulfill many Orders.</li>
<li>An Order can have many Promotions, a Promotion is for zero or more Orders.</li>
<li>An Order Promotion has zero or more customer notifications.</li>
</ul>
<h1 id="table-column-layout">Table Column Layout</h1>
<p>I like my table columns ordered this way.</p>
<ol>
<li>Primary key</li>
<li>Foreign keys</li>
<li>Regular columns</li>
<li>Audit columns</li>
</ol>
<h1 id="general-names">General Names</h1>
<h2 id="pluralize-most-table-names">Pluralize Most Table Names</h2>
<p>Pluralizing table names reduces the chances of keyword conflicts, and matches how the table will (typically) be treated in an ORM tool.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
Customers      |Customer
Salespeople    |Salesperson</code></pre></div>
<p>Don't pluralize many-to-many join tables. By convention, keep the table name parts alphabetical.</p>
<blockquote>
<p><strong>Note</strong><br />
Using Code First, Entity Framework might pluralize this to OrderVendors. Personally, I'd use the FluentAPI to force the table name to the OrderVendor.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
OrderVendor    |OrdersVendors, OrderVendors, VendorOrder              </code></pre></div>
<h2 id="use-pascalcase">Use PascalCase</h2>
<p>Tables and columns should be in <a href="https://en.wikipedia.org/wiki/PascalCase">PascalCase</a>.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
Customers      |customer
OrderNbr       |orderNbr</code></pre></div>
<h2 id="no-dashes-or-underscores">No Dashes or Underscores</h2>
<p>It's tempting to separate words in either table or column names, but don't. Keeping them PascalCased makes the transition to classes easier and clearer. Also, some databases don't play nicely with underscores, or dashes, depending on how they're used.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
OrderVendor    |Order_Vendor
OrderNbr       |order-number
CustomerId     |Customer_ID</code></pre></div>
<h1 id="keys">Keys</h1>
<p>My personal preference is to end key names with &quot;Id&quot;, rather than &quot;ID&quot;. It reads just as well, and is consistent with PascalCasing and .Net naming conventions.</p>
<h2 id="primary-key">Primary Key</h2>
<p>Some people prefer a primary key of just &quot;Id&quot;, but if you need to run SQL queries (and you will), it's easier to have the table name in the primary key for creating joins and reading the results.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span>  c.CustomerId, c.Name, a.AddressId, a.Address1
<span class="kw">FROM</span>    Customers c
        <span class="kw">JOIN</span> Addresses a <span class="kw">on</span> c.CustomerId = a.CustomerId

<span class="co">--Result:</span>

CustomerId  Name  AddressId Address1
<span class="co">----------  ----  --------- ----------</span>
        <span class="dv">23</span>  Ron         <span class="dv">402</span> <span class="dv">12</span> Main St
        <span class="dv">47</span>  Eve          <span class="dv">11</span> <span class="dv">3</span> Polo Ave        </code></pre></div>
<p><strong>Simple Tables</strong><br />
TableName + &quot;Id&quot;</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
CustomerId     |CustomerID, Customer_id, Customer_ID</code></pre></div>
<p><strong>Many-to-Many Tables</strong><br />
A <strong>regular</strong> join table doesn't need its own primary key. Just use the other tables' primary keys to form a composite key.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">OrderVendor
===========
<span class="fu">OrderId</span>  (PK, FK)
<span class="fu">VendorId</span> (PK, FK)</code></pre></div>
<p>The resulting classes should have these properties</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">class</span> Order 
{
  IEnumerable&lt;Vendor&gt; Vendors
}

<span class="kw">class</span> Vendor
{
  IEnumerable&lt;Order&gt; Orders
}</code></pre></div>
<p>A join table <strong>with payload</strong>--one that has its own columns <em>and/or</em> will be joined to another table, should have its own primary key of Table1+Table2+Id</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">OrderPromotion
==============
<span class="fu">OrderPromotionId</span> (PK)
<span class="fu">OrderId</span>          (FK)
<span class="fu">PromotionId</span>      (FK)</code></pre></div>
<p>The resulting classes</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">class</span> Order
{
  IEnumerable&lt;OrderPromotion&gt; OrderPromotions
  <span class="co">//You can manually add this method to get Promotions</span>
  IEnumerable&lt;Promotion&gt; Promotions
  {<span class="kw">get</span> {<span class="kw">return</span> OrderPromotions.<span class="fu">Select</span>(op =&gt; op.<span class="fu">Promotion</span>);}}
}

<span class="kw">class</span> Promotion
{
  IEnumerable&lt;OrderPromotion&gt; Order Promotions
}</code></pre></div>
<h2 id="foreign-key">Foreign Key</h2>
<p>When possible, use the referenced primary key name. If there are multiple foreign keys to the same table, end with the foreign primary key name.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes                       No               
-------------             -----------------
Employees
=========
<span class="fu">EmployeeId</span> (PK)

Customers                 Customers
=========                 =========
<span class="fu">CustomerId</span> (PK)           <span class="fu">Customer_Id</span> (PK)
<span class="fu">SupportEmployeeId</span> (FK)    <span class="fu">SupportPerson</span> (FK)
<span class="fu">InitialEmployeeId</span> (FK)    <span class="fu">InitialEmp_ID</span> (FK)

Addresses                 Addresses
=========                 =========
<span class="fu">AddressId</span>  (PK)           <span class="fu">AddressId</span> (PK)
<span class="fu">CustomerId</span> (FK)           <span class="fu">CustID</span>    (FK)</code></pre></div>
<h1 id="date-columns">Date Columns</h1>
<p>Use a verb, and end the date or datetime column names with &quot;On&quot;.</p>
<p>Following this convention often leads to clearer column meanings, and consistency. For example, DateToPlace or PlaceDateTime becomes PlaceOrderOn.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
OrderedOn      |OrderDateTime
ShouldShipOn   |DateShipExpect, ExpectedShip_DT, AnticipatedDate</code></pre></div>
<h1 id="dont-abbreviate">Don't Abbreviate</h1>
<p>Abbreviations are, by their nature, ambiguous and culture-centric. Avoid them unless they are very common, consistent, and/or well-known in the organization or industry.</p>
<p>A good example of ambiguity is how to abbreviate &quot;number&quot;. Even my schema example, &quot;InvoiceNbr&quot;, is potentially ambiguous. But InvNo is worse. Is there another column &quot;InvYes&quot;?</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
Customers      |Custs
CustomerId     |CustId
FirstName      |Fname
InvoiceNbr     |InvNo</code></pre></div>
<h1 id="use-consistent-names-and-abbreviations-if-you-must">Use Consistent Names (and Abbreviations if You Must)</h1>
<ul>
<li>If you must abbreviate, be consistent.</li>
<li>If it's spelled &quot;InvoiceNbr&quot; in one table, it's that way in <em>all</em> tables.</li>
<li>If everyone knows what DestinationBOL means, that might be OK. But maybe it's better to expand it to DestinationBillOfLading.</li>
</ul>
<p>When in doubt, refer to <strong>Flatt's Law #6: Clarity is more important than brevity.</strong></p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Yes            |No               
---------------|-----------------
InvoiceNbr     |InvoiceNum, InvNumber, Inv_Nmbr</code></pre></div>
<h1 id="auditing">Auditing</h1>
<p>To be honest, I've often found audit columns to be more trouble than they're worth. I think if auditing is needed, it's better to have a separate audit history table where you can record many kinds of changes, including deletions.</p>
<p>But, if I am using them, and am tracking who took an action, I don't link to another table (such as Users or Employees), but instead record the physical name. This significantly reduces linking, and makes it easy to indicate that a process (rather than a person) performed an action. In other words, UpdatedBy is a string column and contains a value like &quot;cflatt&quot; or &quot;Nightly Batch Process&quot;.</p>
<ul>
<li>CreatedOn</li>
<li>CreatedBy</li>
<li>UpdatedOn</li>
<li>UpdatedBy</li>
</ul>
<h1 id="inheritance">Inheritance</h1>
<p>Inheritance can be modeled in the database a couple of different ways. I prefer Table Per Type, as shown by the Employee and Salesperson tables. Note that the Salesperson table has an <em>EmployeeId</em> primary key. This is what implies the inheritance. In the application's class model, these would become:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> Employee
{
  <span class="dt">int</span> EmployeeId
  <span class="dt">string</span> Name 
}

<span class="kw">public</span> <span class="kw">class</span> Salesperson: Employee 
{
  <span class="dt">double</span> CommissionPercent 
}

<span class="kw">public</span> <span class="kw">class</span> Customer
{
  <span class="dt">int</span> CustomerId
  <span class="dt">string</span> Name
  Employee SupportEmployee
  Employee InitialEmployee
  Salesperson Salesperson
}</code></pre></div>
</section>
    
    <footer><p>Copyright &copy; Charles L Flatt</p></footer>
  </body>
</html>
